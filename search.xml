<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何用 git 折磨同事</title>
      <link href="/2021/07/02/%E5%A6%82%E4%BD%95%E7%94%A8-git-%E6%8A%98%E7%A3%A8%E5%90%8C%E4%BA%8B/"/>
      <url>/2021/07/02/%E5%A6%82%E4%BD%95%E7%94%A8-git-%E6%8A%98%E7%A3%A8%E5%90%8C%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>merge  代码的正确姿势</strong></p><h2 id="前情铺垫"><a href="#前情铺垫" class="headerlink" title="前情铺垫"></a>前情铺垫</h2><p>这里就不讲 gitflow 的问题了，最最简单的场景，同事A 和 B，协同开发，假设分支名是 feature。两人共同在 feature  上提交代码。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="http://static.eoyohe.cn/blog/git_init.png" alt></p><h3 id="B-君开了个分支，写了一行B代码"><a href="#B-君开了个分支，写了一行B代码" class="headerlink" title="B 君开了个分支，写了一行B代码"></a>B 君开了个分支，写了一行B代码</h3><p><img src="http://static.eoyohe.cn/blog/git_checkout_b.png" alt></p><h3 id="B-君告知A，请求代码合并到公共分支上"><a href="#B-君告知A，请求代码合并到公共分支上" class="headerlink" title="B 君告知A，请求代码合并到公共分支上"></a>B 君告知A，请求代码合并到公共分支上</h3><p>A 一堆操作猛如虎</p><pre><code class="bash">git checkout featuregit merge -s ours func_b</code></pre><p>通知B君，我合并你代码了。</p><h3 id="这时候-B-君一看，我代码咋没了"><a href="#这时候-B-君一看，我代码咋没了" class="headerlink" title="这时候 B 君一看，我代码咋没了"></a><strong>这时候 B 君一看，我代码咋没了</strong></h3><pre><code class="bash">😠 demo git:(feature) cat code😠 demo git:(feature) </code></pre><p>再看一下 <code>git log</code></p><pre><code class="bash">😠 demo git:(feature) git log --oneline --decorate --graph*   846f001 (HEAD -&gt; feature) Merge branch &#39;func_b&#39; into feature|\\| * 93972fb (func_b) code by b|/* 1c2b405 init</code></pre><p>没毛病，提交已经合并了。</p><h3 id="要不自己再合一下？"><a href="#要不自己再合一下？" class="headerlink" title="要不自己再合一下？"></a><strong>要不自己再合一下？</strong></h3><pre><code class="bash">😡 demo git:(feature) git merge func_bAlready up to date.</code></pre><p>完犊子，git 认为已经合并过了 ，不做处理。🤬</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们合并代码时候，是可以指定合并策略的。<code>recursive</code> 是默认的。</p><ul><li>resolve</li><li>recursive</li><li>octopus</li><li>ours</li><li>subtree</li></ul><p>划重点，<code>ours</code>  策略，即合并时候，不管别人做了什么，以我分支上的提交为主，丢弃掉别人的变动。</p><p>对此 ，我们可以有很多操作坑队友</p><pre><code class="bash">$ git merge --strategy=ours origin/master  # 合并主干代码，但丢弃主干变动$ git pull -s ours # 拉取远程代码，并丢弃队友push的代码</code></pre><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>为啥我会看这些？因为我特么是被坑的那个🤬。</p><p>由于太气了，所以就不好好介绍上述其他策略了，详见大佬文章</p><p><a href="https://blog.walterlv.com/post/git-merge-strategy.html#resolve" target="_blank" rel="noopener">git 合并策略</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为云服务器 443 端口 ssl 无法使用问题排查</title>
      <link href="/2021/03/08/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-443-%E7%AB%AF%E5%8F%A3-ssl-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2021/03/08/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-443-%E7%AB%AF%E5%8F%A3-ssl-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>想部署个服务，解析个三级域名，但是不想去备案，随便在 cloud flare 上解析域名到服务器上，再用 certbot 申请个免费证书，走 ssl 避开备案检测。</p><h2 id="日志报错"><a href="#日志报错" class="headerlink" title="日志报错"></a>日志报错</h2><pre><code>$ curl -v https://notify.eoyohe.xyz:443/ping*   Trying 121.37.13.123...* TCP_NODELAY set* Connected to notify.eoyohe.xyz (121.37.13.123) port 443 (#0)* ALPN, offering h2* ALPN, offering http/1.1* successfully set certificate verify locations:*   CAfile: /etc/ssl/cert.pem  CApath: none* TLSv1.2 (OUT), TLS handshake, Client hello (1):* error:1400410B:SSL routines:CONNECT_CR_SRVR_HELLO:wrong version number* Closing connection 0curl: (35) error:1400410B:SSL routines:CONNECT_CR_SRVR_HELLO:wrong version number</code></pre><h2 id="排查方式"><a href="#排查方式" class="headerlink" title="排查方式"></a>排查方式</h2><h3 id="查资料"><a href="#查资料" class="headerlink" title="查资料"></a>查资料</h3><p><a href="https://stackoverflow.com/questions/53245818/nginx-upstream-to-https-host-ssl3-get-recordwrong-version-number" target="_blank" rel="noopener">Nginx upstream to https host - ssl3_get_record:wrong version number</a></p><blockquote><p>Trying to access it by HTTPS will usually result in a HTTP error response by the server which, when interpreted as the expected TLS handshake response, will result in strange error messages like <code>ssl3_get_record:wrong version number</code>.</p></blockquote><p>也就是说在 http 的接口上进行 https 访问，会得到类似的报错</p><h3 id="排查机器上-443-端口占用"><a href="#排查机器上-443-端口占用" class="headerlink" title="排查机器上 443 端口占用"></a>排查机器上 443 端口占用</h3><ol><li>nginx 修改为 listen 4443;</li><li>lsof -i :443 可以看到已经没有监听中的端口</li></ol><h3 id="排查配置问题"><a href="#排查配置问题" class="headerlink" title="排查配置问题"></a>排查配置问题</h3><p>同上，修改为 4443 端口后，发现可以访问，<em><a href="https://host:4443/ping" target="_blank" rel="noopener">https://host:4443/ping</a></em>  是可以访问的</p><h3 id="排查-nginx-版本问题"><a href="#排查-nginx-版本问题" class="headerlink" title="排查 nginx 版本问题"></a>排查 nginx 版本问题</h3><pre><code># 下载最新版 nginx 源码$ wget http://nginx.org/download/nginx-1.18.0.tar.gz# 解压并编译$ tar zxf nginx-1.18.0.tar.gz$ cd nginx-1.18.0# ssl 模块是必须的，其他模块暂时不知道，可能 gzip 也要$ ./configure --prefix=/usr/local/nginx --with-http_ssl_module$ make &amp;&amp; make install# 复制之前的配置文件并启动编译的nginx$ nginx -s start$ nginx -s reload$ nginx -s stop</code></pre><p>结果一样有该问题</p><h3 id="怀疑是未备案被云供应商拦截了"><a href="#怀疑是未备案被云供应商拦截了" class="headerlink" title="怀疑是未备案被云供应商拦截了"></a>怀疑是未备案被云供应商拦截了</h3><ol><li>搜索 V 站发现很多人被套路云拦截了，但我是华为云</li><li>提交工单询问华为云，不承认，不认同是被拦截</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>用另一个在 良心云 备案过的域名解析到该服务器上，测试 443 端口可以走。</p><h2 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h2><ul><li>服务器上 curl 是通的，外网 curl 不通，说明外网情况下可能确实被华为云拦截了</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>全双工通信方案 socket.io</title>
      <link href="/2020/09/27/%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88%20socket.io/"/>
      <url>/2020/09/27/%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88%20socket.io/</url>
      
        <content type="html"><![CDATA[<p> 一个兼容低版本浏览器的全双工通信方案</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众所周知， <code>http</code> 是半双工通信，在一些场景下，我们需要全双工通信，如 im 系统等。以下介绍本人对相关通信协议的理解。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="http-1-0-1-1"><a href="#http-1-0-1-1" class="headerlink" title="http 1.0/1.1"></a>http 1.0/1.1</h3><p><code>http</code> 协议是基于 <code>TCP</code> 协议上的一个应用层协议。根据 <code>OSI</code> 七层网络模型，<code>http</code> 协议是第七层的应用层协议，<code>tcp</code> 是第四层传输层协议。</p><p>在讲 <code>http</code> 通行方式之前，需要先确定协议版本号，<code>http 1.0/1.1</code> 是都是基于 <code>TCP</code> ，<code>TCP</code> 本身是全双工的通信，但 <code>http/1</code> 这里只用到了半双工，即只能是客户端请求，服务端答复，答复后 <code>http</code> 就断开了 <code>TCP</code> 链接，服务端无法再次发送消息给客户端。</p><p>这里有个混淆点，就是 <code>http/1.1</code> 新增了个头部字段 <code>keepalive</code>，可以达到 <code>TCP</code> 连接复用，即多次 http 请求共用同一个 TCP 连接，避免了多次建立 <code>TCP</code> 隧道。但这跟全双工没有任何关系，本质上还是一个 应-答 模式的半双工通信。</p><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>基于  <code>TCP</code> 的一个全双工通信，为了兼容 http，<code>header</code> 部分跟 http 完全一样。</p><p>通常不是直接建立 <code>websocket</code> 连接，而是发送一个 <code>http</code> 请求，带有以下字段，请求服务器彼此将通信协议升级为 websocket，并约定好通信的 <code>Sec-WebSocket-Key</code>。</p><pre><code>GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13</code></pre><p>其中主要的字段是 <code>Sec-WebSocket-Key</code> 和 <code>Sec-WebSocket-Version</code>。</p><p><code>Sec-WebSocket-Key</code>  是生成通信摘要用，提供请求的基本保护功能。</p><p><code>Sec-WebSocket-Version</code> 是 彼此用的 <code>websocket</code> 协议版本号。</p><p>服务器接受到升级请求后，检查自身是否支持，而后返回握手相应，相应如下。</p><pre><code>HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat</code></pre><p>请求建立，进行消息传输。</p><p>建立传输方式后就是传输内容了，在 <code>websocket</code> 中，数据传输采用帧的概念，区分 <strong>二进制帧</strong> 和 <strong>文本帧</strong> 。</p><p>以下不在详细介绍了，毕竟 <code>websocket</code> 不是本文重点。</p><h3 id="socket-io"><a href="#socket-io" class="headerlink" title="socket.io"></a>socket.io</h3><p>一个支持客户端和服务端全双工通信的网络库。</p><p>socket.io 是用 engine.io 作为底层网络通信库，通信过程中，engine.io 有一套自己的数据格式协议，socket.io 也有自己的一套。</p><p>关系如下：</p><p><img src="https://socket.io/images/dependencies.jpg" alt="Socket.IO dependency graph"></p><p>功能：</p><ol><li>兼容不支持 <code>websocket</code> 的浏览器，通过 <code>polling</code> 实现，用户层无感知</li><li>支持 一对一，命名空间，房间 的通信方式</li><li>支持 <code>掉线重连</code> </li><li>水平扩展</li></ol><p>实现方式：</p><ol><li><p>浏览器支持</p><p><img src="https://camo.githubusercontent.com/fface5a8523859ace9b349fc8922af0a8d6941f4/68747470733a2f2f73617563656c6162732e636f6d2f62726f777365722d6d61747269782f736f636b65742e737667" alt="Sauce Test Status"></p><p>对于支持 <code>websocket</code> 浏览器直接使用 <code>websocket</code> 方式通信。</p><p>连接标识为 <code>sid</code> </p><p>对于不支持的，使用 <code>polling</code> 方式通信，<code>client</code> 端发起 <code>polling</code> 的 <code>GET</code> 请求，如果当前没有数据，则 <code>GET</code> 请求会被 hang 住一个 <code>ping_timeout</code> 的时间。发送数据则通过 <code>POST</code> 方式  。</p></li></ol><ol start="2"><li><p>提供了命名空间(<code>namespace</code>) 做区分不同的路由端点，对于同一个命名空间下，<code>TCP</code>连接是可复用的。</p><p>默认加入了 <code>/</code> 的命名空间，对于不同的命名空间，每一个命名空间都会建立一个<code>TCP</code>连接，但命名空间不等于是 <code>URL path</code> ，不会体现在 <code>URL</code> 路径上，而是作为参数传递给服务端。</p></li><li><p>掉线重连</p><p>客户端对连接做监控，当掉线事件发生时，检查重连。基于连接做监控，所以如果重启浏览器则无效</p><pre><code class="javascript">Manager.prototype.onclose = function (reason) {  debug(&#39;onclose&#39;);  this.cleanup();  this.backoff.reset();  this.readyState = &#39;closed&#39;;  this.emit(&#39;close&#39;, reason);  if (this._reconnection &amp;&amp; !this.skipReconnect) {    this.reconnect();  }};</code></pre></li><li><p>水平扩展</p><p>基于 adapter 做房间管理，可以扩展 <code>redis-adapter</code> <code>kafka-adapter</code>，但 <code>adapter</code> 只是做消息的中间件，即双向通信，本质上就是一个 收 和 发的动作，adapter 只是做消息中间件，监听收和发，不做下文提到的会话功能。</p></li></ol><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>Q：<code>websocket</code> 和 <code>socket.io</code> 区别</p><p>A：<code>socket.io</code> 借鸡生蛋， <code>websocket</code> 协议升级部分一样，但数据传输部分，<code>socket.io</code> 自定了自己的一套传输协议，基于 <code>websocket</code> 的  <code>opcode</code></p><p>为 <code>0x1</code> 的数据帧做数据传输，<code>ping/pong</code> 也与 <code>websocket</code> 协议不一样。因此，无法用 <code>websockt</code> 的客户端连接 <code>socket.io</code> 的服务端，反之亦然。</p><h3 id="socket-io-踩坑"><a href="#socket-io-踩坑" class="headerlink" title="socket.io 踩坑"></a>socket.io 踩坑</h3><ol><li><h4 id="部署问题"><a href="#部署问题" class="headerlink" title="部署问题"></a>部署问题</h4><p><code>socket.io</code> 连接本质上是一种长连接，在服务器上，有多种语言实现，如 <code>node</code> 和 python。</p><p>对于长链接，适合使用异步通信模型，而不是传统的多线程模型，node 是天生异步，python 的 socket.io 可以选择同步模型和异步 <code>async</code> 模型，需要注意的是选择 <code>async</code> 不能很好的利用多核性能。原因是协程的本质导致。</p></li><li><h4 id="会话粘性问题"><a href="#会话粘性问题" class="headerlink" title="会话粘性问题"></a>会话粘性问题</h4><p><code>socket.io</code> 支持 polling 和 <code>websocket</code> 两种协议模式实现全双工通信，并且默认行为是 polling，然后自动升级为 <code>websocket</code> 通信。</p><p><strong>当采用多实例部署时，会遇到在A实例握手后，在B实例升级为websocket，这时候会导致失败</strong>，因为 <code>socket.io</code> 通过 <code>sid</code> 做会话唯一标识，而 <code>sid</code> 是进程数据，不同实例的 <code>sid</code> 哈希表不一致。类似于传统的 <code>cookie</code> 多实例会话粘性问题了。</p><p>解决方案：</p><ol><li><code>socket.io</code> 客户端设置为仅支持 <code>websocket</code> 协议实现，毕竟现在的浏览器基本支持 <code>websocket</code> 了</li><li>修改项目源码，将进程做的会话保持放到中间件如 redis ，但会遇到实例重启的话，需要清理 <code>sid</code> 问题，以及分布式下唯一性 <code>sid</code> 问题。</li><li>网关层实现会话粘性，始终将用户连接分配到同一个实例下</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算之位标志</title>
      <link href="/2020/09/20/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E4%BD%8D%E6%A0%87%E5%BF%97/"/>
      <url>/2020/09/20/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E4%BD%8D%E6%A0%87%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>位运算之位标志位运算就像C语言的指针，易学难精。因此本文只是介绍自己掌握的一些小例子。</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="且运算"><a href="#且运算" class="headerlink" title="且运算"></a>且运算</h3><p>即保留两个数字相同的二进制位</p><p><code>0000 1100</code> &amp; <code>0001 1000</code> =  <code>0000 1000</code></p><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>即保留两者所有的 1 二进制位</p><p><code>0000 1100</code> | <code>0001 1000</code> = <code>0001 1100</code></p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>即两者不一样的位为 1</p><p><code>0000 1100</code> ^ <code>0001 1000</code> = <code>0001 0100</code></p><h3 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h3><p>即对位取反</p><p>! <code>0000 1100</code> = <code>1111 0011</code></p><blockquote><p>其他二进制知识如 补码，反码，原码就不介绍了，是对二进制运算的一种应用</p></blockquote><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><h3 id="标志位用途"><a href="#标志位用途" class="headerlink" title="标志位用途"></a>标志位用途</h3><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>某个字段需要具有多种标识场景。</p><p>比如电商场景下，一个商品可能支持多种支付方式，京东钱包，白条，花呗，微信，支付宝余额等五种可供选择。</p><p>那么商家端的前端需要提供多种支付方式，提供商家打勾支持，</p><p>而用户端前端可能需要根据支付方式，展示对应支付方式的图标选择。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><p>假设支付方式是一个枚举字段，那么五种支付方式的组合就有32种，光写这个枚举字段代码就够累死人了。</p><h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>假设支付方式是一个数组字段，里面是商家打勾的组合支付方式，则是比较简单的，虽然丑了点，但容易理解，只是空间上的开销是比较大的，而且数据库查询运算也有点不方便。</p><h5 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h5><p>在方案二的基础上，把数字的二进制位 作为对应的数组</p><h4 id="位标志"><a href="#位标志" class="headerlink" title="位标志"></a>位标志</h4><p>我们可以把一个整数类型，假设8个位的情况下。字段的二进制如下：</p><pre><code class="latex">0000 0000 </code></pre><p>那么支付方式对应如下的标志位：</p><blockquote><p> 以 js 代码举例，这样可以边看边打开浏览器console验证</p></blockquote><pre><code class="javascript">let jdpay   = 0b00000001 // 京东钱包   =》1let baitiao = 0b00000010 // 京东白条   =》2let huabei  = 0b00000100 // 花呗      =》4let alipay  = 0b00001000 // 支付宝余额 =》8let wechat  = 0b00010000 // 微信      =》16</code></pre><p>可以看到，每种支付方式，对应一个 bit。相当于我们使用这个整数类型字段作为长度为 8 的数组用，数组上每个元素代表一种支付方式。</p><h5 id="或运算："><a href="#或运算：" class="headerlink" title="或运算："></a>或运算：</h5><p>如上所述，我们需要提供支付方式给商家选择，我们用 method 变量作用商家的选择。</p><pre><code class="javascript">let method = 0 // 商家没有选择支付方式method = method | jdpay // 商家打勾了京东钱包 method: 00000000 | 000000001 = 00000001method |= alipay // 商家打勾了支付宝 method: 00000001 | 00001000 = 00001001</code></pre><p>如上，通过或运算，我们可以把对应的支付方式赋值到最终的结果上</p><h5 id="且运算："><a href="#且运算：" class="headerlink" title="且运算："></a>且运算：</h5><p>如上所述，用户端的前端，需要根据商品支持的多种支付方式，提供相应的选择</p><pre><code class="javascript">// 由于商家打勾了京东钱包和支付宝，所以我们的支付方式 method 是 0000 1001if (method &amp; jdpay) { // 9 true, 支持  console.log(&quot;支持京东钱包&quot;)}if (method &amp; baitiao) { // 0 false 不支持  console.log(&quot;支持白条&quot;)}// if ....</code></pre><h5 id="非运算："><a href="#非运算：" class="headerlink" title="非运算："></a>非运算：</h5><p>扩展点，我们提供了 多选项的支付方式给商家选择，商家选择了，我们通过 <strong>或运算</strong> 赋值到支付方式上，但是商家选择又取消了呢，这就涉及到位的清除操作了。</p><p>假设商家取消了 <strong>支付宝余额</strong> ，那么我们需要清除支付方式 <em>0000 1001</em> 上面的 <em>0000 1000</em> 标志位<br>首先，我们对 <strong>支付宝余额</strong> 标志位做按位取反操作</p><pre><code class="javascript">let clear_alipay = !alipay // clear_alipay: 1111 0111</code></pre><p>这样就是一个熟悉的界面了， 我们对支付方式做 <strong>且运算</strong></p><pre><code class="js">method = method &amp; clear_alipay // method:       0000 1001// clear_alipay: 1111 0111//                   &amp;//               0000 0001</code></pre><p>很明显，我们清除了 <strong>支付宝余额</strong> 这种支付方式的标志位。</p><p>一步到位的做法：</p><pre><code class="js">method &amp;= !alipay</code></pre><h4 id="方案对比："><a href="#方案对比：" class="headerlink" title="方案对比："></a>方案对比：</h4><p>方案一明显是最糟糕的做法。灵活性太低。</p><p>方案二是最容易理解业务代码，但不够简洁，方便。</p><p>方案三不好理解，但代码简洁性高，性能也会更好。</p><p>如 android sdk 中，有大量地方地方需要用到 Flag 标志，Google 便是采用这种位标志的方式，使得代码看起来简洁高效。</p><p>如我们在数据库中查询该字段，查询多种支付方式的支持情况。</p><p>方案一 自不必说，把想要查询的枚举值拿来过滤就行。</p><p>方案二 应该是 JSON 语法操作，但这段  JSON 的可读性和语法不是很好上手，依赖于具体的数据库工具，语法特性。比如 5.7 版本之前的mysql 不支持 JSON 运算。并且性能上需要解析JSON的耗费。</p><p>方案三 灵活度极高，例如查询支持京东钱包但不支持花呗</p><pre><code class="mysql">where (method &amp; 1) and not (method &amp; 4)</code></pre><h3 id="交换值"><a href="#交换值" class="headerlink" title="交换值"></a>交换值</h3><p>入门计算机原理的时候，我们就会接触到排序算法的实现，而排序少不了要交换两个位置数字的值。</p><p>简单的举例如下:</p><pre><code class="js">let a = 5let b = 10let temp = aa = bb = temp</code></pre><p>而 异或 运算，会保留两个不一致的位，试想，一个数字如果异或自己，会是怎样呢，答案是0，因为异或左右两边数字的位一模一样。</p><p>那么，两个不一样的数字(a, b)异或，会保留他们差异的位(c)，这时候再异或其中一个数字(a)，会把上面(c)有关于该数字的位清除了。</p><p>那么，我们得到的就是另一个数字(b)了。</p><p>举例如此：</p><pre><code class="js">let a = 5let b = 10a = a ^ bb = a ^ ba = a ^ b</code></pre><h3 id="重复值"><a href="#重复值" class="headerlink" title="重复值"></a>重复值</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><pre><code>输入: [2,2,1]输出: 1</code></pre><p>示例 2:</p><pre><code>输入: [4,1,2,1,2]输出: 4</code></pre><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>利用 两次异或，可以清除重复值，因此我们可以直接将数组数字做异或，出现两次的数字会被两次异或清除掉，最后的结果则为只出现一次的数字。</p><p>代码如下：</p><blockquote><p>python 比较简洁些</p></blockquote><pre><code class="python">class Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        return reduce(xor, nums)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring FactoryBean 初始化问题</title>
      <link href="/2020/08/25/Spring%20FactoryBean%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/25/Spring%20FactoryBean%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>项目使用了 EBean 框架作为数据库依赖管理，通过 FactoryBean 接口，实现了 Ebean Server 的配置初始化操作。</p><pre><code class="kotlin">@Component@Qualifier(&quot;defaultDatabase&quot;)@Primaryclass EbeanDatabaseFactory(        private val primaryDataSource: DataSource) : FactoryBean&lt;Database&gt; {  override fun getObject(): Database? =          DatabaseConfig()                  .apply {                    dataSource = primaryDataSource                    isDdlRun = false                    isDdlGenerate = false                    isDefaultServer = true                    namingConvention = UnderscoreNamingConvention()                    name = &quot;defaultDatabase&quot;                  }                  .let(DatabaseFactory::create)  override fun getObjectType(): Class&lt;*&gt;? = Database::class.java  override fun isSingleton(): Boolean = true</code></pre><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 ORM 层，通过获取 <code>Database</code> 对象做数据库操作</p><pre><code class="kotlin">fun poloDatabase(): Database {  return DB.byName(&quot;defaultDatabase&quot;)}</code></pre><p>出现报错：</p><pre><code>Caused by: io.ebean.datasource.DataSourceConfigurationException: Configuration error creating DataSource for the default Database. This typically means a missing application-test.yaml or missing ebean-test-config dependency. See https://ebean.io/docs/trouble-shooting#datasource    at io.ebean.Ebean$ServerManager.&lt;init&gt;(Ebean.java:87)    at io.ebean.Ebean$ServerManager.&lt;init&gt;(Ebean.java:50)    at io.ebean.Ebean.&lt;clinit&gt;(Ebean.java:45)    ... 70 common frames omittedCaused by: io.ebean.datasource.DataSourceConfigurationException: DataSource user is null?    at io.ebean.datasource.pool.ConnectionPool.&lt;init&gt;(ConnectionPool.java:220)    at io.ebean.datasource.core.Factory.createPool(Factory.java:15)    at io.ebeaninternal.server.core.DefaultContainer.getDataSourceFromConfig(DefaultContainer.java:290)    at io.ebeaninternal.server.core.DefaultContainer.setDataSource(DefaultContainer.java:234)    at io.ebeaninternal.server.core.DefaultContainer.createServer(DefaultContainer.java:100)    at io.ebeaninternal.server.core.DefaultContainer.createServer(DefaultContainer.java:70)    at io.ebeaninternal.server.core.DefaultContainer.createServer(DefaultContainer.java:36)    at io.ebean.EbeanServerFactory.create(EbeanServerFactory.java:58)    at io.ebean.Ebean$ServerManager.getWithCreate(Ebean.java:128)    at io.ebean.Ebean$ServerManager.&lt;init&gt;(Ebean.java:77)    ... 72 common frames omitted</code></pre><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>在 <code>FactoryBean.getObject</code> 打断点排查没有执行到该方法，既 <strong>数据库没有初始化</strong>。</p><p>怀疑是生命周期问题，导致没有注入依赖。</p><p>查找官方 spring 文档，发现以下说明</p><blockquote><p>A standard FactoryBean is not expected to initialize eagerly: Its <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/FactoryBean.html#getObject--" target="_blank" rel="noopener"><code>FactoryBean.getObject()</code></a> will only be called for actual access, even in case of a singleton object. </p></blockquote><p>即 FactoryBean.getObject 需要显式调用。</p><h3 id="为何之前没有这个问题"><a href="#为何之前没有这个问题" class="headerlink" title="为何之前没有这个问题"></a>为何之前没有这个问题</h3><p>之前在代码中显式要求依赖注入了</p><pre><code class="kotlin">@Componentclass UserArgumentResolver(        @Qualifier(&quot;defaultDatabase&quot;) private var poloDatabase: Database): HandlerMethodArgumentResolver {</code></pre><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>显式调用，或者显式依赖注入，在这里感觉有点多余。</p><p>在 <code>FactoryBean</code> 下有个子接口，<code>SmartFactoryBean</code> 实现了 eagerInit 。</p><p>因此，数据库 Bean 改为实现该接口。</p><pre><code class="kotlin">@Component@Qualifier(&quot;defaultDatabase&quot;)@Primaryclass EbeanDatabaseFactory(        private val primaryDataSource: DataSource) : SmartFactoryBean&lt;Database&gt; {  override fun getObject(): Database? =          DatabaseConfig()                  .apply {                    dataSource = primaryDataSource                    isDdlRun = false                    isDdlGenerate = false                    isDefaultServer = true                    namingConvention = UnderscoreNamingConvention()                    name = &quot;defaultDatabase&quot;                  }                  .let(DatabaseFactory::create)  override fun getObjectType(): Class&lt;*&gt;? = Database::class.java  override fun isSingleton(): Boolean = true  override fun isPrototype(): Boolean = true  override fun isEagerInit(): Boolean = true}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wtforms 源码阅读</title>
      <link href="/2020/04/04/wtforms-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/04/04/wtforms-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用 <code>wtforms</code> 时遇到个问题，对于嵌套接口数据，<code>wtforms</code> 表示用<code>FormField</code> 对已有的表单进行复用。</p><p>期望的数据模型：</p><p><img src="http://static.eoyohe.cn/blog/示例数据.png" alt></p><p>期望的<code>wtforms</code> 代码：</p><p><img src="http://static.eoyohe.cn/blog/示例表单.png" alt="示例表单"></p><p>然而，<code>wtforms</code>并不按期望中的代码获取表单值。官方文档也没写清如何获取，遂，翻下源码看下如何解析的。</p><blockquote><p>注：与本次问题无关的代码如 <code>csrf</code> ，<code>html render</code> 等功能暂不关心，因为接口走 <code>RESTful</code> 风格，不通过<code>wtforms</code> 生成表单。</p></blockquote><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>先概要讲下 <code>wtforms</code> 的表单处理过程:</p><ol><li>通过自定义的 <code>FormMeta</code> 类，控制 <code>Form</code> 类的生成，生成类定义下的字段声明字典 <code>_unbound_fields</code></li><li>通过 <code>BaseForm</code> 对 <code>_unbound_fields</code>进行 表单字段 和<code>form</code> 实例的绑定，绑定包括<ul><li>表单字段在form中声明的name</li><li>属性名的前缀</li><li>字段的翻译文本等</li></ul></li><li>field 通过 <code>process</code> 方法获取在 <code>form</code> 中的 value，<code>key</code> 为 <code>prefix+name</code> </li><li>字段通过 <code>validate</code> 方法验证自身约束检查，其中，先验证自身的 <code>validate</code> 方法，再验证属性定义的 <code>validators</code> 验证器列表</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="1-获取-form-定义的字段列表"><a href="#1-获取-form-定义的字段列表" class="headerlink" title="1. 获取 form 定义的字段列表"></a>1. 获取 form 定义的字段列表</h4><p>对于用户定义的 <code>Form</code> 类，通过<code>python</code>的元类特性，内省解析类定义的字段列表，此时该字段类尚未初始化，只是确定类的字段子弹 <code>name-&gt;field_class</code>，对应的代码在 <em>wtforms/form.py</em>  第 <code>185</code> 行，获取类未绑定的字段列表</p><p><img src="http://static.eoyohe.cn/blog/form-call.png" alt="form.__call__"></p><h4 id="2-对字段进行绑定初始化"><a href="#2-对字段进行绑定初始化" class="headerlink" title="2. 对字段进行绑定初始化"></a>2. 对字段进行绑定初始化</h4><ol><li><p>流程走到的 <code>Form</code> 的实例初始化工作，先是通过 <code>BaseForm</code> 的 <code>__init__</code> 对上面元类获取到的类字段列表进行初始化，即将 <code>Field</code> 类初始化，绑定该 <code>Field</code> 在 <code>Form</code> 中定义的 <code>name</code> <code>prefix</code>等属性，相关代码在<em>wtforms/form.py</em>  第 <code>50</code> 行</p><p><img src="http://static.eoyohe.cn/blog/BaseForm.__init__.png" alt="BaseForm.__init__"> </p></li><li><p>对于上面的关键代码 <code>field = meta.bind_field(self, unbound_field, options)</code>，对应 <code>UnboundField</code> 类的 <code>bind_field</code> 函数，跳转过去，可以看到，是返回该字段的一个实例:</p><p><img src="http://static.eoyohe.cn/blog/Field.bind.png" alt="Field.bind"></p><p>如此，则对应看下<code>Field</code>基类的 <code>__init__</code> 方法。忽略其他非目标代码，只关注问题的代码则是如下一行：<code>self.name = _prefix + _name</code></p></li></ol><h4 id="3-对类属性进行覆盖"><a href="#3-对类属性进行覆盖" class="headerlink" title="3. 对类属性进行覆盖"></a>3. 对类属性进行覆盖</h4><p>​     第二步中，对于类定义的字段列表属性，在<code>BaseForm</code>已经将其初始化并绑定了当前的 <code>form</code> 实例，则 <code>Form</code> 实例的 <code>__init__</code> 方法往下走，可以看到，对类属性进行了覆盖为当前实例属性，如此，我们在代码中多次初始化，访问的不是类属性，而是实例属性。</p><p><img src="http://static.eoyohe.cn/blog/属性绑定.png" alt="实例属性绑定"></p><h4 id="4-处理表单数据"><a href="#4-处理表单数据" class="headerlink" title="4. 处理表单数据"></a>4. 处理表单数据</h4><p>在 <code>Form</code> 的 <code>__init__</code> 方法，最后一步，通过调用 <code>self.process</code> 处理当前的表单数据，可以看到，主要为将当前表单处理下发给 <code>Field</code> 的 <code>process</code> 函数进行处理获得自身数据</p><p><img src="http://static.eoyohe.cn/blog/处理表单数据.png" alt="处理表单数据"></p><p>如此，则跳转至 <code>Field</code> 中的 <code>process</code> 方法，忽略掉无关的代码，可以看到，是根据字段的 <code>self.name</code> 从表单中获取数据</p><p><img src="http://static.eoyohe.cn/blog/字段获取表单数据.png" alt="字段获取表单数据"></p><p>而对于 <code>self.name</code> 的变量定义，咱们在之前的 <code>Field.__init__</code> 源码中可以看到是 <code>_prefix + _name</code></p><p>其中，<code>_name</code> 来源于类定义的属性名，<code>_prefix</code> 类初始化时候的参数，默认为空字符串。</p><p>至此，整个 <code>wtforms</code>  框架对表单数据的解析提取基本流程走完。</p><h4 id="5-FormField-字段的用法"><a href="#5-FormField-字段的用法" class="headerlink" title="5. FormField 字段的用法"></a>5. FormField 字段的用法</h4><p>有了上面的源码阅读后，我们可以直接看 <code>FormField</code>的代码实现，可以看到，在 <code>process</code> 方法中，对我们 <code>FormField</code> 类进行了实例化，传递了 <code>prefix</code>。关键代码如下</p><p><img src="http://static.eoyohe.cn/blog/FormField处理数据.png" alt="FormField处理数据"></p><p>即对我们子表单类的复用是通过直接初始化这个子表单类实例作为表单的一个字段。</p><p>初始化时，指定了 <code>self.name + self.separator</code> ，<code>self.separator</code> 在 <code>__init__</code>中默认为 <code>-</code>，这个就不贴代码了。通过上面的源码我们可以知道，子表单字段的表单中的 key 对应应该为 </p><p><code>form.name + formfield.separator + subform.name</code></p><h2 id="问题答案"><a href="#问题答案" class="headerlink" title="问题答案"></a>问题答案</h2><p>通过上面的源码分析，我们可以得出对于上面表单代码，对应的数据结构应该是如下:</p><p><img src="http://static.eoyohe.cn/blog/示例数据2.png" alt="示例数据2"></p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><ol><li>这反人类的数据解析提取方式，我都不好意思跟前端说这么上传数据</li><li>对应的解决方案有个 <a href="https://github.com/kvesteri/wtforms-json" target="_blank" rel="noopener">wtforms-json</a> 库提供了图1数据格式的解析，主要是将 <code>json</code> 的数据转换为 <code>wtforms</code> 期望的扁平化数据格式。然而，在使用时，发现初始化后的表单有时候获取不到数据，故弃之。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> odoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高匿，匿名，透明代理区别</title>
      <link href="/2020/02/12/%E9%AB%98%E5%8C%BF%EF%BC%8C%E5%8C%BF%E5%90%8D%EF%BC%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/02/12/%E9%AB%98%E5%8C%BF%EF%BC%8C%E5%8C%BF%E5%90%8D%EF%BC%8C%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>HTTP代理按匿名度可分为透明代理、匿名代理和高度匿名代理。主要由 server 端收到的 http 请求的头部字段决定代理类型。</p><table><thead><tr><th>proxy/header</th><th>REMOTE_ADDR</th><th>HTTP_VIA</th><th>HTTP_X_FORWARDED_FOR</th></tr></thead><tbody><tr><td>透明代理</td><td>代理服务器IP</td><td>代理服务器IP</td><td>真实客户端IP</td></tr><tr><td>匿名代理</td><td>代理服务器IP</td><td>代理服务器IP</td><td>代理服务器IP</td></tr><tr><td>高匿代理</td><td>代理服务器IP</td><td>不显示</td><td>不显示</td></tr></tbody></table><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>使用透明代理，对方服务器可以知道你使用了代理，并且也知道你的真实IP。 透明代理访问对方服务器所带的HTTP头信息如下：</p><p>REMOTE_ADDR = 代理服务器IP</p><p>HTTP_VIA = 代理服务器IP</p><p>HTTP_X_FORWARDED_FOR = 你的真实IP</p><p>透明代理还是将你的真实IP发送给了对方服务器，因此无法达到隐藏身份的目的。</p><h2 id="匿名代理"><a href="#匿名代理" class="headerlink" title="匿名代理"></a>匿名代理</h2><p>使用匿名代理，对方服务器可以知道你使用了代理，但不知道你的真实IP。匿名代理访问对方服务器所带的HTTP头信息如下：</p><p>REMOTE_ADDR = 代理服务器IP</p><p>HTTP_VIA = 代理服务器IP</p><p>HTTP_X_FORWARDED_FOR = 代理服务器IP</p><p>匿名代理隐藏了你的真实IP，但是向访问对象透露了你是使用代理服务器访问他们的。</p><h2 id="高匿代理"><a href="#高匿代理" class="headerlink" title="高匿代理"></a>高匿代理</h2><p>使用高匿名代理，对方服务器不知道你使用了代理，更不知道你的真实IP。高匿名代理访问对方服务器所带的HTTP头信息如下：</p><p>REMOTE_ADDR = 代理服务器IP</p><p>HTTP_VIA 不显示</p><p>HTTP_X_FORWARDED_FOR 不显示</p><p>高匿名代理隐藏了你的真实IP，同时访问对象也不知道你使用了代理，因此隐蔽度最高。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS 网络加速小结</title>
      <link href="/2020/01/27/VPS-%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/01/27/VPS-%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>网络加速从应用层讲，可以通过代理机器，比如常见的网游加速器等</p><p><img src="/2020/01/27/VPS-网络加速小结/主机代理过程.jpg" alt></p><p>通过中继节点加速网络请求。不过除了应用层，在底层上，也可以通过对 TCP/IP 层优化提高网络复用率从而提高网络体验。</p><h2 id="加速工具"><a href="#加速工具" class="headerlink" title="加速工具"></a>加速工具</h2><p>从加速手段讲，可以有两种，<strong>单边加速</strong> 和 <strong>双边加速</strong></p><h3 id="单边加速"><a href="#单边加速" class="headerlink" title="单边加速"></a>单边加速</h3><p>常见如 <code>锐速</code> <code>BBR</code> 等软件，通过优化底层的 <a href="https://blog.sometimesnaive.org/article/8.html" target="_blank" rel="noopener"><strong>拥塞控制算法</strong></a>，提高网络传输速度。</p><p>以下记录下用过的底层网络加速工具。</p><h4 id="锐速-ServerSpeeder"><a href="#锐速-ServerSpeeder" class="headerlink" title="锐速 ServerSpeeder"></a>锐速 ServerSpeeder</h4><ul><li><p>介绍</p><p>第一个接触的网络加速工具，国内公司开发的，不过已经闭源，据说转为面向企业用户，但是找不到官网都…</p><p>目前网络上基本是破解版锐速安装，可以看下这个仓库 <a href="https://github.com/91yun/serverspeeder" target="_blank" rel="noopener">serverspeeder</a>。提供下载安装以及一键脚本。</p></li><li><p>原理</p><p>锐速是从内核层次进行网络优化，其基本原理是通过系统算法预判，对可能丢包的数据包，重复再发一遍，也就是重复发包，从而降低了丢包率。因此使用锐速在一定程素上加速VPS的流量消耗。</p><p>由于降低丢包率，因此锐速对于看视频之类的持续性数据传输的网络请求，会有比较明显的速度提升。</p></li><li><p>总结</p><p>通过重复发包降低丢包率，对于海外VPS提升明显，但由于缺少开源支持，持续更新，个人觉得会跟不上时代，比如目前锐速支持的内核才 3.1 内核</p></li></ul><h4 id="谷歌BBR加速"><a href="#谷歌BBR加速" class="headerlink" title="谷歌BBR加速"></a>谷歌BBR加速</h4><ul><li><p>介绍</p><p>来自谷歌内部员工开发的网络加速模块，第二个接触的加速工具，开源项目，仓库地址 <a href="https://github.com/google/bbr/" target="_blank" rel="noopener">BBR</a> ，由于是开源项目，因此有网友进行各种参数调整等，所以还有</p><ul><li>BBR Plus </li><li>BBR 魔改版</li><li>BBR 原版</li></ul><p>这几个常见版本，具体特点以及效果对比，没有进行测试过。</p></li><li><p>安装</p><p>由于个人水平有限，因此用的是一键安装脚本进行的安装。一键脚本仓库 <a href="https://github.com/cx9208/Linux-NetSpeed" target="_blank" rel="noopener">Linux-NetSpeed</a></p><p>一键脚本安装方式</p><pre><code class="shell">wget --no-check-certificate -O tcp.sh https://github.com/cx9208/Linux-NetSpeed/raw/master/tcp.sh &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></pre></li><li><p>原理</p><p>BBR 加速是通过调整拥塞控制算法，优化流量传输，就像道路交通，降低阻塞自然能提交车辆速度。</p></li><li><p>总结</p><p>开源持续更新项目，有Google亲爹，应该会比较香，看好 <code>BBR</code> 模块。</p></li></ul><h3 id="双边加速"><a href="#双边加速" class="headerlink" title="双边加速"></a>双边加速</h3><p>单边加速是通过服务器端对TCP拥塞，丢包等情况进行优化，基于TCP包的协议基础上，而双边加速，一般是通过服务器和客户端建立一条自己的通信隧道，数据通信通过隧道传输，因此通信协议可以按照隧道内自有的数据协议传输，相当于黑盒操作。个人认为，就像 HTTP 通信，和自定义 RPC 通信同理。</p><p>目前的双边加速，个人而言，只用过 <a href="https://github.com/xtaci/kcptun/" target="_blank" rel="noopener">kcptun</a> 。</p><h4 id="kcptun"><a href="#kcptun" class="headerlink" title="kcptun"></a>kcptun</h4><ul><li><p>介绍</p><p>go 语言写的一款基于 <code>KCP</code> 协议实现的双边隧道通信工具，分为服务端和客户端。</p><p>服务端监听指定端口，以及转发到目标端口。</p><p>客户端同理，连接远程服务器端口，并本地监听端口。此后通过本地端口隧道进行通信。</p><p><code>KCP</code> 协议可以在这里了解下。<a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">传送门</a></p></li><li><p>安装</p><p>可在 <a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="noopener">release</a> 下载对应的操作系统版本。</p><p>基于 ssh 隧道通信加速示范如下</p><pre><code class="shell"># 服务器端./server_linux_amd64 -t &#39;127.0.0.1:22&#39; -l &quot;:4000&quot; -mode fast3 -nocomp -sockbuf 16777217 -dscp 46# 本地机器./client_darwin_amd64 -r &#39;server_host:4000&#39; -l &quot;:8000&quot; -mode fast3 -nocomp -autoexpire 900 -sockbuf 16777217 -dscp 46# 本地 ssh 连接远程服务器 ssh ubuntu@127.0.0.1 -p 8000</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上安装hive问题解决</title>
      <link href="/2019/11/08/Mac%E4%B8%8A%E5%AE%89%E8%A3%85hive%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/11/08/Mac%E4%B8%8A%E5%AE%89%E8%A3%85hive%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>一开始按照书上选择源码安装，结果配置环境变量太麻烦了，后选择通过brew安装。简单命令如下</p><pre><code class="shell">brew install hadoopbrew install hive</code></pre><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="guava版本不一致问题"><a href="#guava版本不一致问题" class="headerlink" title="guava版本不一致问题"></a>guava版本不一致问题</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>直接敲 <code>hive</code> 命令，遇到以下报错</p><pre><code class="bash">LF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/usr/local/Cellar/hive/3.1.2/libexec/lib/log4j-slf4j-impl-2.10.0.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V    at org.apache.hadoop.conf.Configuration.set(Configuration.java:1357)    at org.apache.hadoop.conf.Configuration.set(Configuration.java:1338)    at org.apache.hadoop.mapred.JobConf.setJar(JobConf.java:536)    at org.apache.hadoop.mapred.JobConf.setJarByClass(JobConf.java:554)    at org.apache.hadoop.mapred.JobConf.&lt;init&gt;(JobConf.java:448)    at org.apache.hadoop.hive.conf.HiveConf.initialize(HiveConf.java:5141)    at org.apache.hadoop.hive.conf.HiveConf.&lt;init&gt;(HiveConf.java:5099)    at org.apache.hadoop.hive.common.LogUtils.initHiveLog4jCommon(LogUtils.java:97)    at org.apache.hadoop.hive.common.LogUtils.initHiveLog4j(LogUtils.java:81)    at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:699)    at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:683)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.apache.hadoop.util.RunJar.run(RunJar.java:323)    at org.apache.hadoop.util.RunJar.main(RunJar.java:236)</code></pre><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>谷歌之得到以下答案</p><blockquote><p>关键在： com.google.common.base.Preconditions.checkArgument 这是因为hive内依赖的<strong>guava.jar</strong>和hadoop内的<strong>版本不一致</strong>造成的。</p></blockquote><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><pre><code class="bash"># 查看版本$ ls /usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/guava*/usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/guava-27.0-jre.jar$ ls /usr/local/Cellar/hive/3.1.2/libexec/lib/guava* /usr/local/Cellar/hive/3.1.2/libexec/lib/guava-19.0-jre.jar# hadoop 版本比 hive 高，替换之$ mv /usr/local/Cellar/hive/3.1.2/libexec/lib/guava-19.0.jar /tmp # 个人习惯保留下副本$ cp /usr/local/Cellar/hadoop/3.2.1/libexec/share/hadoop/common/lib/guava-27.0-jre.jar /usr/local/Cellar/hive/3.1.2/libexec/lib/ # 替换</code></pre><h3 id="jdk-版本不一致问题"><a href="#jdk-版本不一致问题" class="headerlink" title="jdk 版本不一致问题"></a>jdk 版本不一致问题</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>解决完上面 jar 包问题后再次敲入 <code>hive</code> 命令遇到以下报错</p><pre><code class="bash">Hive Session ID = c2bd3ba5-9902-48d3-8d7b-e63bf64444cfException in thread &quot;main&quot; java.lang.ClassCastException: class jdk.internal.loader.ClassLoaders$AppClassLoader cannot be cast to class java.net.URLClassLoader (jdk.internal.loader.ClassLoaders$AppClassLoader and java.net.URLClassLoader are in module java.base of loader &#39;bootstrap&#39;)    at org.apache.hadoop.hive.ql.session.SessionState.&lt;init&gt;(SessionState.java:413)    at org.apache.hadoop.hive.ql.session.SessionState.&lt;init&gt;(SessionState.java:389)    at org.apache.hadoop.hive.cli.CliSessionState.&lt;init&gt;(CliSessionState.java:60)    at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:705)    at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:683)    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.base/java.lang.reflect.Method.invoke(Method.java:566)    at org.apache.hadoop.util.RunJar.run(RunJar.java:323)    at org.apache.hadoop.util.RunJar.main(RunJar.java:236)</code></pre><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>谷歌之找到问题在于 JDK 版本不一致。个人系统是 MacOS 10.15 ，里面的 JDK 版本 11</p><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>安装低版本 jdk ，可直接在oracle官网下载的 1.8 版本 jdk 安装。</p><p>安装后的系统默认 <code>jdk</code> 还是 11，但是在 <code>/Library/Java/JavaVirtualMachines</code> 目录下可看到有多个 <code>jdk</code> 版本共存。</p><pre><code class="bash">$ ll /Library/Java/JavaVirtualMachinestotal 0drwxr-xr-x  4 root  wheel   128B Nov  3 17:01 ./drwxr-xr-x  4 root  wheel   128B Oct 24 08:35 ../drwxr-xr-x  3 root  wheel    96B Nov 15  2018 jdk-11.0.1.jdk/drwxr-xr-x  3 root  wheel    96B Nov  3 16:58 jdk1.8.0_212.jdk/</code></pre><p>因此修改 <code>hive</code> 启动环境下的 <code>JAVA_HOME</code> 变量:</p><ol><li><p>添加写入权限，默认 <code>hive</code> 可执行文件是只读的</p><pre><code class="bash">chmod +w `which hive`</code></pre></li><li><p>修改文件内容</p><p>原内容如下</p><pre><code class="bash">#!/bin/bashJAVA_HOME=&quot;$(/usr/libexec/java_home --version 1.7+)&quot; HIVE_HOME=&quot;/usr/local/Cellar/hive/3.1.2/libexec&quot; exec &quot;/usr/local/Cellar/hive/3.1.2/libexec/bin/hive&quot; &quot;$@&quot;</code></pre><p>修改后如下</p><pre><code class="bash">#!/bin/bash#JAVA_HOME=&quot;$(/usr/libexec/java_home --version 1.7+)&quot;JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk/Contents/Home&quot;HIVE_HOME=&quot;/usr/local/Cellar/hive/3.1.2/libexec&quot;exec &quot;/usr/local/Cellar/hive/3.1.2/libexec/bin/hive&quot; &quot;$@&quot;</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg调整分辨率height not divisible by 2问题解决</title>
      <link href="/2019/10/12/ffmpeg%E8%B0%83%E6%95%B4%E5%88%86%E8%BE%A8%E7%8E%87height-not-divisible-by-2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/10/12/ffmpeg%E8%B0%83%E6%95%B4%E5%88%86%E8%BE%A8%E7%8E%87height-not-divisible-by-2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>调整视频分辨率时候，以下命令</p><pre><code class="shell">ffmpeg -i a.mp4 -y -c:v libx264 -movflags +faststart -vf scale=640:-1 -c:a copy b.mp4</code></pre><ul><li>-i 表示输入视频</li><li>-y 不询问，默认执行</li><li>-c:v libx264 指定编解码器为 x264</li><li><p>-movflags +faststart 输出为 fragment MP4</p></li><li><p>-vf 使用视频滤镜</p></li><li><p>scale=640:-1 缩放视频，宽度为640，高度按原宽高比例自适应</p></li><li>-c:a copy 复制音频</li></ul><p>执行后报错:</p><pre><code class="bash">ffmpeg version 4.1.4 Copyright (c) 2000-2019 the FFmpeg developers  built with Apple LLVM version 10.0.1 (clang-1001.0.46.4)  configuration: --prefix=/usr/local/Cellar/ffmpeg/4.1.4_1 --enable-shared --enable-pthreads --enable-version3 --enable-avresample --cc=clang --host-cflags=&#39;-I/Library/Java/JavaVirtualMachines/adoptopenjdk-12.0.1.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/adoptopenjdk-12.0.1.jdk/Contents/Home/include/darwin&#39; --host-ldflags= --enable-ffplay --enable-gnutls --enable-gpl --enable-libaom --enable-libbluray --enable-libmp3lame --enable-libopus --enable-librubberband --enable-libsnappy --enable-libtesseract --enable-libtheora --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libx265 --enable-libxvid --enable-lzma --enable-libfontconfig --enable-libfreetype --enable-frei0r --enable-libass --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-librtmp --enable-libspeex --enable-videotoolbox --disable-libjack --disable-indev=jack --enable-libaom --enable-libsoxr  libavutil      56. 22.100 / 56. 22.100  libavcodec     58. 35.100 / 58. 35.100  libavformat    58. 20.100 / 58. 20.100  libavdevice    58.  5.100 / 58.  5.100  libavfilter     7. 40.101 /  7. 40.101  libavresample   4.  0.  0 /  4.  0.  0  libswscale      5.  3.100 /  5.  3.100  libswresample   3.  3.100 /  3.  3.100  libpostproc    55.  3.100 / 55.  3.100Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &#39;a.mp4&#39;:  Metadata:    major_brand     : isom    minor_version   : 512    compatible_brands: isomiso2avc1mp41    encoder         : Lavf54.20.4  Duration: 00:03:19.12, start: 0.000000, bitrate: 2612 kb/s    Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x654 [SAR 1:1 DAR 640:327], 2417 kb/s, 25 fps, 25 tbr, 12800 tbn, 50 tbc (default)    Metadata:      handler_name    : VideoHandler    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 188 kb/s (default)    Metadata:      handler_name    : SoundHandlerStream mapping:  Stream #0:0 -&gt; #0:0 (h264 (native) -&gt; h264 (libx264))  Stream #0:1 -&gt; #0:1 (copy)Press [q] to stop, [?] for help[libx264 @ 0x7fc73d804600] height not divisible by 2 (640x327)Error initializing output stream 0:0 -- Error while opening encoder for output stream #0:0 - maybe incorrect parameters such as bit_rate, rate, width or heightConversion failed!</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>问题在于  <code>height not divisible by 2</code></p><p>原视频的分辨率为 <code>1280x654</code></p><p>自适应缩放到640后为 <code>640x327</code></p><p>查资料发现 x264 编解码器要求视频的分辨率都是偶数。</p><p>因此，ffmpeg的命令修改为</p><pre><code class="bash">ffmpeg -i a.mp4 -y -c:v libx264 -movflags +faststart -vf scale=640:-2 -c:a copy b.mp4</code></pre><p>主要为 scale 修改为 640:-2</p><p>根据<a href="https://ffmpeg.org/ffmpeg-filters.html#scale" target="_blank" rel="noopener">官网文档介绍</a></p><blockquote><p>If one and only one of the values is -n with n &gt;= 1, the scale filter will use a value that maintains the aspect ratio of the input image, calculated from the other specified dimension. After that it will, however, make sure that the calculated dimension is divisible by n and adjust the value if necessary.</p></blockquote><p>如果宽高值设置为负数，则表示对应的值取按比例缩放后的自适应值，且能被n整除。</p><p>因此，取 <code>640:-2</code> 表示宽度为640，高度自适应后能被2整除的值。则为 <code>640x328</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>odoo升级模块后字段为默认值问题修复</title>
      <link href="/2019/04/24/odoo%E5%8D%87%E7%BA%A7%E6%A8%A1%E5%9D%97%E5%90%8E%E5%AD%97%E6%AE%B5%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%80%BC%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
      <url>/2019/04/24/odoo%E5%8D%87%E7%BA%A7%E6%A8%A1%E5%9D%97%E5%90%8E%E5%AD%97%E6%AE%B5%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%80%BC%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>升级了自己二开的发票模块后，出现原有发票数据的数量为0的情况</p><h2 id="解决过程："><a href="#解决过程：" class="headerlink" title="解决过程："></a>解决过程：</h2><ol><li><p>本地恢复线上升级前的数据库，并 <code>git</code> 切换到升级前的版本，模拟线上升级前的环境，开始升级</p></li><li><p>由于是从 <code>master</code> 合并 <code>dev</code> 分支，<code>commit</code> 数有七八个，二分法通过<code>git checkout</code>切换版本升级，确定出现问题的 <code>commit</code></p></li><li><p>第一次二分法升级后出现问题，重新初始化模拟环境继续二分法，结果没找到问题，一直<code>checkout</code>到最新代码都没有出现。查找异常 <code>commit</code> 失败</p></li><li><p>重新初始化升级环境，直接升级到最新代码，检查log，搜索关键字，发现</p><blockquote><p>odoo.schema: Table ‘account_invoice_line’’: column ‘quantity’: dropped constraint NOT NULL<br>odoo.schema: Table ‘account_invoice_line’: renamed column ‘quantity’ to ‘’quantity_moved1’<br>odoo.schema: Table ‘account_invoice_line’: added column ‘quantity’ of type int4</p></blockquote><p>该日志，确定问题为数据库字段发生变化，导致字段数据变为新字段默认值0</p></li><li><p>查找该字段的代码，发现是重构了源码的字段，源码是 <code>Float</code> 类型，重构成了 <code>Integer</code> 类型，并添加注释为中文注释。猜测当时的情况应该只是想修改为中文注释…</p></li></ol><h2 id="问题确定"><a href="#问题确定" class="headerlink" title="问题确定"></a>问题确定</h2><p>由于字段类型前后不一致，导致升级过程中，<code>odoo</code> 重命名了旧字段，创建新字段。</p><p>另外存在一个问题，</p><p>发现在二开代码中，该字段是在 <strong>2018-10-10</strong> 提交，项目升级前的代码版本是 <strong>2018-11-29</strong> 现在时间是 <strong>2019-04-23</strong> ，讲道理如果存在这个问题，应该之前每次升级就会出现了，并且一开始的通过 <code>checkout</code> 升级，也有时出现有时没有，很奇怪。<code>odoo</code> 迷之问题。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ul><li><p>数据库方面：</p><pre><code class="sql">ALTER TABLE &quot;public&quot;.&quot;account_invoice_line&quot;   DROP COLUMN &quot;quantity&quot;;ALTER TABLE &quot;public&quot;.&quot;account_invoice_line&quot; RENAME COLUMN &quot;quantity_moved1&quot; TO &quot;quantity&quot;;</code></pre></li><li><p>代码方面：</p><p>出现问题的 <code>quantity</code> 字段修正之前的 <code>Integer</code> 类型为 <code>Float</code>类型</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> odoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>odoo源码阅读之自动重载的实现</title>
      <link href="/2018/12/13/odoo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/12/13/odoo%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在阅读源码的时候发现原来odoo是有重载代码的实现的, 加上上一篇的模块远程部署更新功能,组合可以实现在终端上重载服务器了.</p><h2 id="odoo服务器启动过程"><a href="#odoo服务器启动过程" class="headerlink" title="odoo服务器启动过程"></a>odoo服务器启动过程</h2><p>在odoo的server启动过程中, 首先是执行cli的main方法解析命令参数,默认则是启动服务器.</p><pre><code class="python"># odoo/cli/command.py:33def main():    # ....此处省略若干代码    # 可以看到默认如果第一个参数不是-或者--开头的参数则是server命令启动服务器    command = &quot;server&quot;    # ....此处省略若干代码    if command in commands:        o = commands[command]()        o.run(args)    else:        sys.exit(&#39;Unknow command %r&#39; % (command,))</code></pre><p>接下来看服务器的run方法, <code>odoo/cli/server.py</code> 的run方法直接是执行main函数,因此看main函数.</p><pre><code class="python"># odoo/cli/server.pydef main(args):    # 检查运行环境和解析配置    check_root_user()    odoo.tools.config.parse_config(args)    check_postgres_user()    report_configuration()    config = odoo.tools.config    csv.field_size_limit(500 * 1024 * 1024)    # 如果有指定数据库,数据库不存在则创建    preload = []    if config[&#39;db_name&#39;]:        preload = config[&#39;db_name&#39;].split(&#39;,&#39;)        for db_name in preload:            try:                odoo.service.db._create_empty_database(db_name)            except ProgrammingError as err:                if err.pgcode == errorcodes.INSUFFICIENT_PRIVILEGE:                    _logger.info(&quot;Could not determine if database %s exists, &quot;                                 &quot;skipping auto-creation: %s&quot;, db_name, err)                else:                    raise err            except odoo.service.db.DatabaseExists:                pass    # 导入导出翻译    if config[&quot;translate_out&quot;]:        export_translation()        sys.exit(0)    if config[&quot;translate_in&quot;]:        import_translation()        sys.exit(0)    # 指定多进程    if config[&#39;workers&#39;]:        odoo.multi_process = True    stop = config[&quot;stop_after_init&quot;]    setup_pid_file()    # 敲重点,服务器开始运行    rc = odoo.service.server.start(preload=preload, stop=stop)    sys.exit(rc)</code></pre><p>odoo服务器启动:</p><pre><code class="python"># odoo/service/server.pydef start(preload=None, stop=False):    &quot;&quot;&quot; Start the odoo http server and cron processor.    &quot;&quot;&quot;    global server    load_server_wide_modules()    odoo.service.wsgi_server._patch_xmlrpc_marshaller()    # 选择服务器类型, gevent服务器 or 多进程 or 多线程    if odoo.evented:        server = GeventServer(odoo.service.wsgi_server.application)    elif config[&#39;workers&#39;]:        if config[&#39;test_enable&#39;] or config[&#39;test_file&#39;]:            _logger.warning(&quot;Unit testing in workers mode could fail; use --workers 0.&quot;)        server = PreforkServer(odoo.service.wsgi_server.application)        # Workaround for Python issue24291, fixed in 3.6 (see Python issue26721)        if sys.version_info[:2] == (3,5):            # turn on buffering also for wfile, to avoid partial writes (Default buffer = 8k)            werkzeug.serving.WSGIRequestHandler.wbufsize = -1    else:        server = ThreadedServer(odoo.service.wsgi_server.application)    # 敲重点, 监视文件变化从而自动重载    watcher = None    if &#39;reload&#39; in config[&#39;dev_mode&#39;]:        if watchdog:            watcher = FSWatcher()            watcher.start()        else:            _logger.warning(&quot;&#39;watchdog&#39; module not installed. &quot;                            &quot;Code autoreload feature is disabled&quot;)    if &#39;werkzeug&#39; in config[&#39;dev_mode&#39;]:        server.app = DebuggedApplication(server.app, evalex=True)    # 敲重点, 启动服务器    rc = server.run(preload, stop)    # 如果标志 phoenix 为 true 则在服务器退出后重新载入    # like the legend of the phoenix, all ends with beginnings    if getattr(odoo, &#39;phoenix&#39;, False):        if watcher:            watcher.stop()        _reexec()    return rc if rc else 0</code></pre><h2 id="watchdog实现文件内容更改则reload服务器"><a href="#watchdog实现文件内容更改则reload服务器" class="headerlink" title="watchdog实现文件内容更改则reload服务器"></a>watchdog实现文件内容更改则reload服务器</h2><p>在上面的服务器启动过程中, 可以看到, 如果我们配置了dev_mode包含了reload选项, 并且watchdog变量不为空的话, 则会启动watcher观察文件系统.那么, watchdog在哪导入的呢,在源码中有:</p><pre><code class="python"># odoo/service/server.pytry:    import watchdog    from watchdog.observers import Observer    from watchdog.events import FileCreatedEvent, FileModifiedEvent, FileMovedEventexcept ImportError:    watchdog = None</code></pre><p>可以看到, 尝试导入 <code>watchdog</code> , 导入失败则为None. 为此我专门去odoo的 <code>requirements.txt</code> 看了下, 并没有 <code>watchdog</code> 这个依赖, 当然, <code>pip install watchdog</code> 就好了, 但是官方这么做是为啥呢? 一脸黑线🌚</p><p>接下来就是watchdog的事件处理了:</p><pre><code class="python">class FSWatcher(object):    def __init__(self):        self.observer = Observer()        for path in odoo.modules.module.ad_paths:            _logger.info(&#39;Watching addons folder %s&#39;, path)            # 注册为自己为watchdog的事件处理            self.observer.schedule(self, path, recursive=True)    def dispatch(self, event):        if isinstance(event, (FileCreatedEvent, FileModifiedEvent, FileMovedEvent)):            if not event.is_directory:                path = getattr(event, &#39;dest_path&#39;, event.src_path)                # 如果是py代码则尝试导入, try 没有语法错误 则 重启服务器                if path.endswith(&#39;.py&#39;) and not os.path.basename(path).startswith(&#39;.~&#39;):                    try:                        source = open(path, &#39;rb&#39;).read() + b&#39;\n&#39;                        compile(source, path, &#39;exec&#39;)                    except FileNotFoundError:                        _logger.error(&#39;autoreload: python code change detected, FileNotFound for %s&#39;, path)                    except SyntaxError:                        _logger.error(&#39;autoreload: python code change detected, SyntaxError in %s&#39;, path)                    else:                        if not getattr(odoo, &#39;phoenix&#39;, False):                            _logger.info(&#39;autoreload: python code updated, autoreload activated&#39;)                            restart()    def start(self):        self.observer.start()        _logger.info(&#39;AutoReload watcher running&#39;)    def stop(self):        self.observer.stop()        self.observer.join()</code></pre><p>在 <code>__init__</code> 有个有点意思的是 <code>self.observer.schedule(self, path, recursive=True)</code> 代码, 查看 <code>schedule</code> 函数签名可以看到对于第一个参数 <strong>event_handler</strong> 的类型是要求:</p><blockquote><p> `watchdog.events.FileSystemEventHandler` or a subclass </p></blockquote><p>而 <code>watchdog.events.FileSystemEventHandler</code> 的核心就是 <strong>dispatch</strong> 方法. </p><p>看来源码这用的是动态语言的鸭子模型了. (这段有点啰嗦了)</p><h2 id="信号处理重载服务器"><a href="#信号处理重载服务器" class="headerlink" title="信号处理重载服务器"></a>信号处理重载服务器</h2><p>在odoo服务器启动过程源码中, 可以看到odoo的服务器类型有三种: gevent, 多进程, 多线程.</p><p>而默认的就是多线程版本。在多线程版本的start代码中，有一段信号注册代码：</p><pre><code class="python">    def start(self, stop=False):        _logger.debug(&quot;Setting signal handlers&quot;)        if os.name == &#39;posix&#39;:            signal.signal(signal.SIGINT, self.signal_handler)            signal.signal(signal.SIGTERM, self.signal_handler)            signal.signal(signal.SIGCHLD, self.signal_handler)            signal.signal(signal.SIGHUP, self.signal_handler)            signal.signal(signal.SIGQUIT, dumpstacks)            signal.signal(signal.SIGUSR1, log_ormcache_stats)        elif os.name == &#39;nt&#39;:            import win32api            win32api.SetConsoleCtrlHandler(lambda sig: self.signal_handler(sig, None), 1)        test_mode = config[&#39;test_enable&#39;] or config[&#39;test_file&#39;]        if test_mode or (config[&#39;http_enable&#39;] and not stop):            # some tests need the http deamon to be available...            self.http_spawn()</code></pre><p>该代码表示， 如果系统内核是posix(Uni*系统)，则注册一系列信号处理。</p><p>如果是nt内核（Windows系统），则将事件默认交给<strong>signal_handler</strong> 函数处理。</p><p>接下来就看对应的信号处理函数：</p><pre><code class="python">    def signal_handler(self, sig, frame):        if sig in [signal.SIGINT, signal.SIGTERM]:            # shutdown on kill -INT or -TERM            self.quit_signals_received += 1            if self.quit_signals_received &gt; 1:                # logging.shutdown was already called at this point.                sys.stderr.write(&quot;Forced shutdown.\n&quot;)                os._exit(0)            # interrupt run() to start shutdown            raise KeyboardInterrupt()        elif sig == signal.SIGHUP:            # restart on kill -HUP            odoo.phoenix = True            self.quit_signals_received += 1            # interrupt run() to start shutdown            raise KeyboardInterrupt()</code></pre><p>可以看到，如果是SIGHUP信号，则标记phoenix为True，同时抛出 <strong>KeyboardInterrupt</strong> 中断服务器，此后，回到我们的odoo服务器启动过程源码的最后一段：</p><pre><code class="python">    # like the legend of the phoenix, all ends with beginnings    if getattr(odoo, &#39;phoenix&#39;, False):        if watcher:            watcher.stop()        _reexec()</code></pre><p>由此可见，当odoo服务器进程收到SIGHUP信号时，将会重载odoo代码。</p><p>对此，我们可以这么操作发送SIGHUP信号：</p><pre><code class="shell">$ kill -1 pid# 或者$ kill -s SIGHUP pid</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>reload只是重载了python代码，像xml这些视图配置的，还是需要去升级模块才能够更新的，但是可以用deploy命令配合。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> odoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>odoo远程部署命令</title>
      <link href="/2018/12/03/odoo%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/03/odoo%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>阅读源码的cli模块发现一个远程部署模块的命令，在官方文档并没有说，发现隐藏功能！</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>在odoo里面写界面是很烦人的，每次写完需要重启服务器并且到app界面点击升级模块才能看到效果，用部署命令即可一条命令刷新界面效果。也就是热重载。当然，这个也可以用于安装新模块。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>在 <code>odoo/cli/deploy.py</code> 源码中可以看到，部署命令的操作是将模块文件上传在运行中的odoo执行安装操作。</p><pre><code class="python">def authenticate(self, server, login, password, db=&#39;&#39;):print(&quot;Authenticating on server &#39;%s&#39; ...&quot; % server)# Fixate session with a given db if anyself.session.get(server + &#39;/web/login&#39;, params=dict(db=db))args = dict(login=login, password=password, db=db)res = self.session.post(server + &#39;/base_import_module/login&#39;, args)if res.status_code == 404:raise Exception(&quot;The server &#39;%s&#39; does not have the &#39;base_import_module&#39; installed.&quot; % server)elif res.status_code != 200:raise Exception(res.text)return res.headers.get(&#39;x-csrf-token&#39;)</code></pre><p>查找 <code>/base_import_module/login</code> 路由，发现在 addons/base_import_module 模块里，因此，我们需要先在web管理界面安装该模块 <code>base_import_module</code> 。</p><h2 id="deploy命令介绍"><a href="#deploy命令介绍" class="headerlink" title="deploy命令介绍"></a>deploy命令介绍</h2><pre><code class="bash">$ odoo deploy -husage: odoo deploy [-h] [--db DB] [--login LOGIN] [--password PASSWORD][--verify-ssl] [--force]path [url]Deploy a module on an Odoo instancepositional arguments:path                 Path of the module to deployurl                  Url of the server (default=http://localhost:8069)optional arguments:-h, --help           show this help message and exit--db DB              Database to use if server does not use db-filter.--login LOGIN        Login (default=admin)--password PASSWORD  Password (default=admin)--verify-ssl         Verify SSL certificate--force              Force init even if module is already installed. (willupdate `noupdate=&quot;1&quot;` records)</code></pre><p>odoo的命令解析都是用argparse模块，因此我们在传参的时候按照默认习惯就好。</p><p>从帮助上看，部署命令的使用为 odoo deploy 模块路径 网站url –login 用户名 –password 密码</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="bash">$ odoo deploy addons/my_module http://localhost:8888 --login account@email.com --password=this_is_passwordAuthenticating on server &#39;http://localhost:8888&#39; ...Zipping module directory...Uploading module file...Successfully imported module &#39;my_module&#39;</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>阅读 <code>base_import_module</code> 源码可以发现该命令只是安装或者升级模块的xml文件，并不会更新已经在运行的python代码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>odoo xml语法杂记</title>
      <link href="/2018/11/12/odoo-xml%E8%AF%AD%E6%B3%95%E6%9D%82%E8%AE%B0/"/>
      <url>/2018/11/12/odoo-xml%E8%AF%AD%E6%B3%95%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="odoo-xml语法杂记"><a href="#odoo-xml语法杂记" class="headerlink" title="odoo xml语法杂记"></a>odoo xml语法杂记</h1><blockquote><p>总结记录在odoo的xml中踩的坑</p></blockquote><ol><li><p>domain多条件过滤语法</p><p>domain 使用 <em><a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">波兰表示法</a></em> </p><blockquote><p>以二元运算为例，从左至右读入表达式，遇到一个操作符后跟随两个操作数时，则计算之，然后将结果作为操作数替换这个操作符和两个操作数；重复此步骤，直至所有操作符处理完毕。</p></blockquote><p> eg. 计算顺序</p><pre><code> [&#39;|&#39;,&#39;&amp;&#39;,&#39;|&#39;,a,b,c,&#39;&amp;&#39;,d,e] [&#39;|&#39;,&#39;&amp;&#39;,(a | b),c,&#39;&amp;&#39;,d,e] [&#39;|&#39;,((a | b) &amp; c),&#39;&amp;&#39;,d,e] [&#39;|&#39;,((a | b) &amp; c),(d &amp; e)] [(((a | b) | c) | (d &amp; e))]</code></pre></li><li><p><strong>one2many</strong> , <strong>many2many</strong> 记录的关联选项</p><p>   情景：<em>sale.order</em> 表下有个 <strong>one2many</strong> 字段关联着 <em>sale.order.line</em>，现在为 order 添加一个 line 销售明细行。</p><pre><code class="python">   order.write({&#39;line_ids&#39;: [(0, 0, {values})]})</code></pre><p>   则将会用values创建一个line记录，并且关联到order中。</p><p>   具体语法：</p><pre><code>   (0, 0, { values }) 从给定的values创建一条记录 (create(values))   (1, ID, { values }) 更新id=ID的记录值(调用write(values))   (2,ID) 去除和id=ID的对象主从链接关系,并且删除这个对象（调用unlink方法）   (3,ID)去除和id=ID的对象主从链接关系,但是不删除这个对象   (4,ID)添加主从链接关系到id=ID的对象。   (5) 去除所有的链接关系,也就是循环所有的从数据且调用(3,ID)   (6,0,[IDs]) 用IDs里面的记录替换原来链接的记录，即先执行(5)再循环IDs执行（4,I</code></pre></li><li><p><strong>one2many</strong>, <strong>many2many</strong> 字段禁止禁止创建按钮：</p><pre><code class="xml">   &lt;field name=&quot;field_name&quot; options=&quot;{&#39;no_create&#39;: True}&quot;/&gt;</code></pre></li><li><p><strong>ref</strong> 和 <strong>eval</strong> 语法：</p><ul><li><strong>eval</strong> :把eval的值通过作为python运算返回该属性</li><li><strong>ref</strong> :视图的方法，根据 module_name.xml_id 返回数据库id<br>example:<br>由于每个view，action都是一个数据库的record，因此可以使用继承inhertit_id继承并用 <strong>ref</strong> 查找该record<pre><code class="xml">&lt;record id=&quot;view_partner_tree&quot; model=&quot;ir.ui.view&quot;&gt;&lt;field name=&quot;name&quot;&gt;res.partner.form&lt;/field&gt;&lt;field name=&quot;model&quot;&gt;res.partner&lt;/field&gt;&lt;field name=&quot;inherit_id&quot; ref=&quot;base.view_partner_tree&quot;/&gt;&lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;  &lt;field name=&quot;tomorrow&quot; eval=&quot;(DateTime.now() + timedelta(days=1)).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)&quot; /&gt;    &lt;/field&gt;</code></pre></li></ul></li><li><p>控制xml文件只在安装时执行，防止多次升级覆盖数据：</p><pre><code class="xml"> &lt;odoo&gt;     &lt;data noupdate=&quot;1&quot;&gt;...&lt;/data&gt; &lt;/odoo&gt;</code></pre></li><li><p>在xml中设置model相关field的默认值<br>   使用 <code>default_</code> 前缀</p><pre><code class="xml"> &lt;record id=&quot;action_specimen_orders&quot; model=&quot;ir.actions.act_window&quot;&gt;     &lt;field name=&quot;type&quot;&gt;ir.actions.act_window&lt;/field&gt;     &lt;field name=&quot;view_type&quot;&gt;form&lt;/field&gt;     &lt;field name=&quot;view_mode&quot;&gt;tree,form&lt;/field&gt;     &lt;field name=&quot;context&quot;&gt;{&#39;default_field_name&#39;: field_value}&lt;/field&gt; &lt;/record&gt;</code></pre></li><li><p>控制xml文件只在安装时执行，防止多次升级覆盖数据：</p><pre><code class="xml"> &lt;odoo&gt;     &lt;data noupdate=&quot;1&quot;&gt;...&lt;/data&gt; &lt;/odoo&gt;</code></pre></li><li><p>创建用户权限分组：</p><p> odoo是数据驱动的框架，因此对于权限分组，实则是将用户分组，因此需要先创建一个分组，这里使用xml创建一个record。</p><pre><code class="xml"> &lt;!-- 新建一个分组标签 --&gt; &lt;record model=&quot;ir.module.category&quot; id=&quot;module_category_test&quot;&gt;     &lt;field name=&quot;name&quot;&gt;测试&lt;/field&gt; &lt;/record&gt; &lt;!-- 新建一个分组 --&gt; &lt;record id=&quot;base.group_hr_manager&quot; model=&quot;res.groups&quot;&gt;     &lt;field name=&quot;name&quot;&gt;Manager&lt;/field&gt;     &lt;field name=&quot;comment&quot;&gt;the user will have an access to the human resources configuration as well as statistic reports.&lt;/field&gt;     &lt;field name=&quot;category_id&quot; ref=&quot;base.module_category_human_resources&quot;/&gt;     &lt;field name=&quot;implied_ids&quot; eval=&quot;[(4, ref(&#39;base.group_hr_user&#39;))]&quot;/&gt;     &lt;field name=&quot;users&quot; eval=&quot;[(4, ref(&#39;base.user_root&#39;))]&quot;/&gt; &lt;/record&gt; &lt;!-- @name:用户组名，这个或以翻译的 @comment:用户组的注释 @category_id 用户组所属的模块名 @implied_ids 基于哪个用户组，这个层级关系 &lt;field name=&quot;implied_ids&quot; eval=&quot;[(4, ref(&#39;base.group_user&#39;))]&quot;/&gt;是最基础的 用户名，最初是基于这个，后面一层一层递增，像上面 base.group_hr_user 定义时就是基于最基础 @users 预设用户属于这个用户组 --&gt;</code></pre><p> 当创建好分组了后，即可在各个方面使用该分组。</p><p> 以下是创建一个过滤规则，针对users过滤，并且只有该分组内的用户才可以看得到</p><pre><code class="xml"> &lt;record model=&quot;ir.rule&quot; id=&quot;rule1&quot;&gt; &lt;field name=&quot;name&quot;&gt;rule1&lt;/field&gt; &lt;field name=&quot;model_id&quot; ref=&quot;model_res_users&quot;/&gt; &lt;field name=&quot;global&quot; eval=&quot;True&quot;/&gt; &lt;field name=&quot;domain_force&quot;&gt;[1,’=’,1]&lt;/field&gt; &lt;field name=&quot;groups&quot; eval=&quot;[(4,ref(&#39;base.group_hr_manager&#39;))]&quot;/&gt; &lt;/record&gt; &lt;!--name: 规则名称--&gt; &lt;!--model_id: 对应的模型--&gt; &lt;!--global: 是否是全局--&gt; &lt;!--domain_force: 过滤条件--&gt; &lt;!--groups: 属于哪个组--&gt;</code></pre><p> 以下是针对menuitem只有特定用户显示</p><pre><code class="xml"> &lt;menuitem id=&quot;menu_manage&quot; name=&quot;manager&quot; groups=&quot;base.group_hr_manager&quot;/&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> odoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>odoo添加自定义导出按钮</title>
      <link href="/2018/11/02/odoo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E5%87%BA%E6%8C%89%E9%92%AE/"/>
      <url>/2018/11/02/odoo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E5%87%BA%E6%8C%89%E9%92%AE/</url>
      
        <content type="html"><![CDATA[<p>想要导出产品，由于自定义的导出在导出一些关联字段时，导出的是id而不是想要的name参数，所以只能手动写一个导出功能。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>添加一个导出的 <code>act_window</code> 到产品表，该 <code>act_window</code> 对应一个导出记录表的form视图，form视图定义了一个button，button点击生成一个excel并新开一个文件下载地址的url窗口。</p><h3 id="创建导出记录表"><a href="#创建导出记录表" class="headerlink" title="创建导出记录表"></a>创建导出记录表</h3><p>由于导出按钮是跳转到对应的一个form视图，需要有一个导出文件的二进制字段提供下载，所以创建一个导出的model</p><pre><code class="python">from odoo import fields, models, apiimport base64import xlwtfrom io import BytesIOclass ExportWizard(models.Model):    _name = &#39;export.wizard&#39;    file = fields.Binary(&#39;導出文件&#39;)    def generate_excel(self, product_ids):        &quot;&quot;&quot;        根据产品数据导出excel        :param product_ids: product.template()        :return:        &quot;&quot;&quot;        workbook = xlwt.Workbook(encoding=&#39;utf-8&#39;)        worksheet = workbook.add_sheet(&#39;產品清單&#39;)        # add header        header = [&#39;編號&#39;, &#39;名稱&#39;, &#39;單價&#39;, &#39;單位&#39;]        for col in range(len(header)):            worksheet.write(0, col, header[col])        # add data        for row in range(1, len(product_ids)+1):            product_id = product_ids[row-1]            worksheet.write(row, 0, product_id.id)            worksheet.write(row, 1, product_id.name)            worksheet.write(row, 2, product_id.list_price)            worksheet.write(row, 3, product_id.uom_id.name)        # save        buffer = BytesIO()        workbook.save(buffer)        return base64.encodebytes(buffer.getvalue())    @api.multi    def action_export(self):        context = dict(self._context or {})        active_ids = context.get(&#39;active_ids&#39;, []) or []        product_tmpl_ids = self.env[&#39;product.template&#39;].search([(&#39;id&#39;, &#39;in&#39;, active_ids)])        self.file = self.generate_excel(product_tmpl_ids)        value = dict(            type=&#39;ir.actions.act_url&#39;,            target=&#39;new&#39;,            url=&#39;/web/content?model=%s&amp;id=%s&amp;field=file&amp;download=true&amp;filename=product.xls&#39; % (self._name, self.id),        )        return value</code></pre><h3 id="创建导出记录表的视图"><a href="#创建导出记录表的视图" class="headerlink" title="创建导出记录表的视图"></a>创建导出记录表的视图</h3><pre><code class="xml">&lt;record id=&quot;wizard_view&quot; model=&quot;ir.ui.view&quot;&gt;    &lt;field name=&quot;name&quot;&gt;export wizard&lt;/field&gt;    &lt;field name=&quot;model&quot;&gt;export.wizard&lt;/field&gt;    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;        &lt;form string=&quot;導出記錄&quot;&gt;            &lt;footer&gt;                &lt;button string=&quot;下載&quot; class=&quot;btn-primary&quot; name=&quot;action_export&quot; type=&quot;object&quot;/&gt;                &lt;button string=&quot;關閉&quot; class=&quot;btn-default&quot; special=&quot;cancel&quot; /&gt;            &lt;/footer&gt;        &lt;/form&gt;    &lt;/field&gt;&lt;/record&gt;</code></pre><p><img src="https://i.loli.net/2018/11/02/5bdc000fa4374.png" alt></p><h3 id="添加导出按钮到目标表的action-动作-下拉列表中"><a href="#添加导出按钮到目标表的action-动作-下拉列表中" class="headerlink" title="添加导出按钮到目标表的action(动作)下拉列表中"></a>添加导出按钮到目标表的action(动作)下拉列表中</h3><p><img src="https://i.loli.net/2018/11/02/5bdc000fe1ed2.png" alt></p><pre><code class="xml">&lt;act_window id=&quot;export_wizard_action&quot;            name=&quot;導出Excel&quot;            src_model=&quot;product.template&quot;            res_model=&quot;export.wizard&quot;            view_type=&quot;form&quot; view_mode=&quot;form&quot;            target=&quot;new&quot;/&gt;</code></pre><p>其中，</p><ul><li><p><code>src_model</code> 表示在哪个 model 上添加这个 <code>act_window</code></p></li><li><p>res_model 表示这个 <code>act_window</code> 将会跳转到哪一个 model</p></li><li><p>view_type <strong>res_model</strong> 显示的视图类型</p></li><li><p>view_mode <strong>res_model</strong> 显示的视图种类列表</p></li><li><p>target 视图在当前视图(<code>src_model</code>) 上的打开方式。</p><ul><li>在当前视图上打开(current)</li><li>使用全屏模式(fullscreen)</li><li>使用弹出框(new)</li><li>用main代替current来清除面包屑导航</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> odoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk命令使用实践</title>
      <link href="/2018/05/26/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/05/26/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>awk</code> 算是个古老的命令了，上古神器。现在已经很少看到使用，可能我周围没什么运维的朋友吧，至少我周围没见到用这个命令，不过也确实有点不好学，所以记录下。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code class="bash">awk [options] &#39;script&#39; var=value file(s)awk [options] -f scriptfile var=value file(s)</code></pre><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><pre><code class="bash">-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:，多个分隔符(例如:和制表符)为awk -F &#39;[:\t]&#39; 或者 &#39;[:|\t]&#39; 或者 &#39;[&quot;:&quot;|&quot;\t&quot;]&#39;，表示没发现区别-v var=value   赋值一个用户定义变量，将外部变量传递给awk-f scripfile  从脚本文件中读取awk命令-m[fr] val   对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</code></pre><h2 id="摘要介绍"><a href="#摘要介绍" class="headerlink" title="摘要介绍"></a>摘要介绍</h2><p>日常Linux流程，遇见不会的命令，先 <code>man command</code>，所以 <code>awk</code> 的文档介绍是这么写的 <code>mawk - pattern scanning and text processing language</code> 用我的菜鸡英语翻译就是：模式扫描和文本处理语言。</p><p>是的，<code>awk</code> 并不是一个二进制程序命令，而是一门脚本语言，主要用来匹配处理文本，就像 <code>bash</code> 一样，同理 <code>bash</code> 有多个解释器: <code>zsh</code>, <code>fish</code> 等一样，<code>awk</code> 也有，例如我 <code>man awk</code> 看到的是 <code>mawk</code>，我的是Ubuntu16.04系统。因此既然 <code>awk</code> 是语言，<code>mawk</code> 是解释器而已，所以我们的操作可以是将 <code>awk</code> 代码直接在终端中使用，就像<code>bash</code>的 <code>echo &#39;hello world&#39;</code>一样，也可以写成一个脚本，通过 <code>awk -f filename</code> 一样执行。</p><p>awk的处理方式是从输入流从逐行读取文本，然后进行 <strong>模式-动作</strong> 流程,即</p><pre><code class="bash">pattern    { action }</code></pre><p>小例子:</p><pre><code class="bash">$ ls | awk &#39;1 &lt; 2 {print &quot;废话&quot;}&#39;废话</code></pre><p>这里的 <code>1 &lt; 2</code> 就是 <em>pattern</em> 了，而 <em>action</em> 要包裹在 <code>{}</code> 里面。</p><h2 id="使用实践-剪切获取ifconfig中的ip地址"><a href="#使用实践-剪切获取ifconfig中的ip地址" class="headerlink" title="使用实践-剪切获取ifconfig中的ip地址"></a>使用实践-剪切获取ifconfig中的ip地址</h2><p>文本如下</p><pre><code class="bash">$ ifconfig wlp8s0 wlp8s0    Link encap:Ethernet  HWaddr 5c:93:a2:76:e5:c1            inet addr:192.168.123.111  Bcast:192.168.123.255  Mask:255.255.255.0          inet6 addr: fe80::44cd:39be:6aea:d61a/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:698409 errors:0 dropped:0 overruns:0 frame:0          TX packets:353304 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:949454893 (949.4 MB)  TX bytes:38261895 (38.2 MB)</code></pre><p>简单的剪切思路，先通过正则表达式获取ip地址那一行，awk默认的分隔符是空格，所以很明显我们的ip地址在第二列。</p><pre><code class="bash">$ ifconfig wlp8s0 | awk &#39;$0 ~ /inet addr/ {printf $2}&#39;addr:192.168.123.111</code></pre><p>解释如下:</p><ul><li><code>$0</code> 表示当前读取的整行，上面文本有</li><li><code>~</code> 表示开启正则匹配</li><li><code>/inet addr/</code> 正则匹配内容，表达式要写在//中间。即/pattern/</li><li><code>{print $2}</code> 表示匹配成功的话打印当前行的第二列。$2是内键变量，参考下面附录</li></ul><p>接下来就很明显了，针对剪切出来的 <code>addr:192.168.123.111</code> 我们只需要以 <code>:</code> 为分隔符打印第二列就可以了。命令如下:</p><pre><code class="bash">ifconfig wlp8s0 | awk &#39;$0 ~ /inet addr/ {print $2}&#39; | awk -F: &#39;{print $2}&#39;</code></pre><h2 id="小提示："><a href="#小提示：" class="headerlink" title="小提示："></a>小提示：</h2><ul><li><strong>当把awk代码直接放在终端中使用时，建议使用 <code>&#39;</code> 而不是 <code>&quot;</code> 包括起来，因为 <code>&quot;</code> 可能会被bash解析了变量$0之类</strong></li><li><strong><code>print</code>和<code>printf</code>的区别在于<code>printf</code>可以格式化输出,但是<code>print</code>自带换行</strong></li></ul><p><code>printf</code> 示例如下</p><pre><code class="bash"># 打印行号$ ls / | awk &#39;{printf &quot;%d  %s\n&quot;, NR, $0}&#39; 行号:1  bin行号:2  boot行号:3  cdrom行号:4  dev行号:5  etc行号:6  home行号:7  initrd.img行号:8  initrd.img.old行号:9  lib行号:10  lib64行号:11  lost+found行号:12  media行号:13  mnt行号:14  opt行号:15  proc行号:16  root行号:17  run行号:18  sbin行号:19  snap行号:20  srv行号:21  sys行号:22  tmp行号:23  usr行号:24  var行号:25  vmlinuz行号:26  vmlinuz.old</code></pre><blockquote><p>事实上这用 <code>nl</code> 命令即可了。 </p></blockquote><pre><code class="bash">ls / | nl</code></pre><h2 id="附录-内键变量"><a href="#附录-内键变量" class="headerlink" title="附录-内键变量"></a>附录-内键变量</h2><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>\$n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td>\$0</td><td>完整的输入记录</td></tr><tr><td>ARGC</td><td>命令行参数的数目</td></tr><tr><td>ARGIND</td><td>命令行中当前文件的位置(从0开始算)</td></tr><tr><td>ARGV</td><td>包含命令行参数的数组</td></tr><tr><td>CONVFMT</td><td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td></tr><tr><td>ERRNO</td><td>最后一个系统错误的描述</td></tr><tr><td>FIELDWIDTHS</td><td>字段宽度列表(用空格键分隔)</td></tr><tr><td>FILENAME</td><td>当前文件名</td></tr><tr><td>FNR</td><td>各文件分别计数的行号</td></tr><tr><td>FS</td><td>字段分隔符(默认是任何空格)</td></tr><tr><td>IGNORECASE</td><td>如果为真，则进行忽略大小写的匹配</td></tr><tr><td>NF</td><td>一条记录的字段的数目</td></tr><tr><td>NR</td><td>已经读出的记录数，就是行号，从1开始</td></tr><tr><td>OFMT</td><td>数字的输出格式(默认值是%.6g)</td></tr><tr><td>OFS</td><td>输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td></tr><tr><td>ORS</td><td>输出记录分隔符(默认值是一个换行符)</td></tr><tr><td>RLENGTH</td><td>由match函数所匹配的字符串的长度</td></tr><tr><td>RS</td><td>记录分隔符(默认是一个换行符)</td></tr><tr><td>RSTART</td><td>由match函数所匹配的字符串的第一个位置</td></tr><tr><td>SUBSEP</td><td>数组下标分隔符(默认值是/034)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程和协程的概念</title>
      <link href="/2018/05/19/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/05/19/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="线程-协程-进程"><a href="#线程-协程-进程" class="headerlink" title="线程 协程 进程"></a>线程 协程 进程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程是系统资源分配的最小单位, 系统由一个个进程(程序)组成<br>一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。</p><ul><li>文本区域存储处理器执行的代码</li><li>数据区域存储变量和进程执行期间使用的动态分配的内存；</li><li>堆栈区域存储着活动过程调用的指令和本地变量。</li></ul></blockquote><p>因此进程的创建和销毁都是相对于系统资源,所以是一种比较昂贵的操作。<br>进程有三个状态:</p><ol><li>等待态：等待某个事件的完成；</li><li>就绪态：等待系统分配处理器以便运行；</li><li>运行态：占有处理器正在运行。</li></ol><p>进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.</p><blockquote><p>通信问题: &nbsp;&nbsp; 由于进程间是隔离的,各自拥有自己的内存内存资源, <em>因此相对于线程比较安全</em>, 所以不同进程之间的数据只能通过 <em>IPC(Inter-Process Communication)</em> 进行通信共享.</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote><ul><li>线程属于进程</li><li>线程共享进程的内存地址空间</li><li>线程几乎不占有系统资源<br>通信问题: &nbsp;&nbsp;进程相当于一个容器,而线程而是运行在容器里面的,因此对于容器内的东西,线程是共同享有的,因此线程间的通信可以直接通过全局变量进行通信,但是由此带来的例如多个线程读写同一个地址变量的时候则将带来不可预期的后果,因此这时候引入了各种锁的作用,例如互斥锁等。</li></ul></blockquote><p>同时多线程是不安全的,当一个线程崩溃了,会导致整个进程也崩溃了,即其他线程也挂了,<br>但多进程而不会,一个进程挂了,另一个进程依然照样运行。</p><ul><li><strong><em>进程是系统分配资源的最小单位</em></strong></li><li><strong><em>线程是CPU调度的最小单位</em></strong></li><li><em>由于默认进程内只有一个线程,所以多核CPU处理多进程就像是一个进程一个核心</em></li></ul><h3 id="线程和进程的上下文切换"><a href="#线程和进程的上下文切换" class="headerlink" title="线程和进程的上下文切换"></a>线程和进程的上下文切换</h3><p>进程切换分3步:</p><ol><li>切换页目录以使用新的地址空间</li><li>切换内核栈</li><li>切换硬件上下文</li></ol><p>而线程切换只需要第2、3步,因此进程的切换代价比较大</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><blockquote><ul><li>协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等</li><li>协没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.</li><li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li></ul></blockquote><h3 id="协程的实现：迭代器和生成器"><a href="#协程的实现：迭代器和生成器" class="headerlink" title="协程的实现：迭代器和生成器"></a>协程的实现：迭代器和生成器</h3><ul><li>迭代器：&nbsp;实现了迭代接口的类,接口函数例如:current,key,next,rewind,valid。迭代器最基本的规定了对象可以通过next返回下一个值，而不是像数组，列表一样一次性返回。语言实现：在Java的foreach遍历迭代器对(数组)，Python的for遍历迭代器对象(tuple，list，dist)。</li><li>生成器：&nbsp;使用 <em>yield</em> 关键字的函数,可以多次返回值，生成器实际上也算是实现了迭代器接口(协议)。即生成器也可通过next返回下一个值。</li></ul><blockquote><p>协程举例：在Python中，使用了yield的函数为生成器函数，即可以多次返回值。则生成器可以暂停一下，转而执行其他代码，再回来继续执行函数往下的代码。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透frp及树莓派的应用</title>
      <link href="/2017/11/13/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Ffrp%E5%8F%8A%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2017/11/13/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8Ffrp%E5%8F%8A%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在上一篇文章<a href="2017/11/01/树莓派之下载机和NAS服务器/">树莓派之下载机和NAS服务器</a>中,我们介绍了怎么用树莓派搭建下载机,并且在局域网内可以在任何一台设备上添加下载服务,但是当我们不在家的时候,就没办法了,这样有点麻烦,比如在公司的时候,想远程下载一部电影,回家的时候可以看.对此,解决方法有两个:  </p><ul><li>方法一:跟运营商要求一个公网IP,而后在路由器上进行端口映射到树莓派上,这样我们就可以通过公网IP访问我们的树莓派了.缺点是,一般运营商不给…很麻烦,或者当环境是内网并且路由器不是自己的,例如公司的,那就做不了主了</li><li>方法二:进行内网穿透,将自己的一些提供外界访问的端口通过中转服务器穿透出去,这就是今天的主题了.</li></ul></blockquote><h2 id="内网穿透介绍"><a href="#内网穿透介绍" class="headerlink" title="内网穿透介绍"></a>内网穿透介绍</h2><p>  内网穿透说白了就是将自己的内网机器的端口,通过端口映射和外网机器连在一起,即访问外网的X端口即相当于访问内网的Y端口.  </p><p>  内网穿透工具即第三方服务提供商介绍:</p><ul><li><p><strong><em><a href="https://hsk.oray.com/" target="_blank" rel="noopener">花生壳</a></em></strong><br>花生壳是国内的动态域名解析软件,即支持内网端口动态解析到某一个域名上,这应该是知名度最高的一个了吧,不过是收费的  </p></li><li><p><strong><em><a href="https://github.com/inconshreveable/ngrok/" target="_blank" rel="noopener">ngrok</a></em></strong><br>ngrok是免费的开源软件,支持多端口映射,算是有点年代了,<a href="https://ngrok.com/" target="_blank" rel="noopener">官网</a>提供免费的端口映射服务,不过免费账号或者游客账号只支持一个端口映射,有多端口映射需求的话,要么付费,要么自己搭建ngrok服务器,毕竟这是一个开源项目,有提供源码供编译运行.  </p></li></ul><ul><li><strong><em><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></em></strong><br><strong>frp</strong>相对于<strong>ngrok</strong>算是一个新项目了,同样支持多端口映射,二级域名等功能,不过目前不知道有什么第三方服务商.博主是通过在自己服务器搭建运行的,下面就是讲解怎么在服务器搭建frp并且端口映射到树莓派</li></ul><h2 id="搭建与运行"><a href="#搭建与运行" class="headerlink" title="搭建与运行"></a>搭建与运行</h2><p>  frp提供发行版和源码编译步骤,编译就算了吧,有发行版直接拿来用就好了.<br>  frp发行版<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">地址</a>,下载对应操作系统和CPU架构的就可以了,像我服务是下载amd64的,树莓派是arm的.</p><h3 id="服务器端安装运行"><a href="#服务器端安装运行" class="headerlink" title="服务器端安装运行"></a>服务器端安装运行</h3><p>  下载解压frp后,有服务器端和客户端各有三个文件,服务器是frps开头的文件,客户端是frpc,参考server和client两个单词还是比较形象的 0.0   </p><p>  frps开头的文件,frps是二进制执行程序,frps.ini 和 frps_full.ini 同样是配置文件,不过frps.ini是基本的配置文件,frps_full.ini是完整的配置文件,包含各项配置参数.简单配置如下:</p><pre><code class="bash">  [common]  bind_port = 7000 # 服务器端口  privilege_token = ThisIsAToken # token秘钥   privilege_allow_ports = 7000-8000 # 白名单端口,只允许服务器的这部分端口被映射出去  log_file = ./frps.log  log_level = info  dashboard_port = 7001 # 控制面板端口  dashboard_user = account # 控制面板登录账号  dashboard_pwd = password</code></pre><p>  这里需要解释一下,frps运行后,如果没有限制白名单端口的话,客户端是可以指定任意端口连接映射的,这样会造成端口滥用不好管理,并且如果没有token验证,任何一台设备只要知道了你服务器IP都可以将你的服务器作为免费的端口映射中转服务器</p><p>  而后启动运行即可,这里就不作为服务通过systemctl启动了,用另一个神器 <strong><a href="https://tmux.github.io/" target="_blank" rel="noopener">tmux</a></strong> ,终端复用神器,提供会话功能,即可实现关闭ssh连接后程序依然执行,比起自带的nohup强大的是不仅后台执行,而且可以随时切回前台.</p><pre><code class="bash">  sudo apt install tmux # 安装tmux  tmux # 直接启动一个会话,默认会话名是 0  ./frps -c frps.ini # 指定配置文件运行frps  # 这时候使用快捷键 Ctrl+b d 即可将会话后台运行(detach).注:按住Ctrl和b键,松手,按d键  tmux attach -t 0 # 回到刚才的会话(attach)的命令</code></pre><h3 id="客户端安装运行"><a href="#客户端安装运行" class="headerlink" title="客户端安装运行"></a>客户端安装运行</h3><p>  树莓派上下载解压arm版本,同样是一个客户端文件和服务器文件,这里同样我们自定义自己的配置文件</p><pre><code class="bash">  # vim frpc.ini  [common]  server_addr = x.x.x.x # 这里为你的服务器IP  server_port = 7000  privilege_token = ThisIsAToken # 服务器和客户端的 privilege_token需要一样才可以连接得上  [ssh]  type = tcp  local_ip = 127.0.0.1  local_port = 22  remote_port = 7002  [http]  type = tcp  local_ip = 127.0.0.1  local_port = 80  remote_port = 7003  [rpc]  local_ip = 127.0.0.1  local_port = 6800  remote_port = 7004</code></pre><p>  而后通过 <strong>tmux</strong> 运行 frpc -c frpc.ini 命令就可以了</p><h3 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h3><p>  当frps服务器端程序运行后,我们上面已经配置了 <strong>Dashboard</strong> 的端口和账号了,即可通过浏览器输入 x.x.x.x:dashboard_port 查看frp状态,查看客户端是否连接上来了,以及流量统计</p><h3 id="树莓派aria2的应用"><a href="#树莓派aria2的应用" class="headerlink" title="树莓派aria2的应用"></a>树莓派aria2的应用</h3><p>  通过上面的配置,我们将树莓派的80端口和6800端口映射出去了<br>  有人可能会问,映射80端口不就好了,事实上,为了远程下载,80端口反而是非必须的,因为在上一篇文章我们介绍过了,<strong>aria2</strong> 远程下载的实现是通过rpc远程调用机制实现的,因此, <strong>webui-aria2</strong> 项目只是一个通过js实现 <strong>aria2</strong> 远程调用的一个应用,假设我们自己的电脑也有 <strong>webui-aria2</strong> 的话,只需浏览器打开,在 <strong>webui-aria2</strong> 的设置-连接设置添加 <strong>aria2</strong> 的rpc端口即可.如图所示:  </p><p>  <img src="/2017/11/13/内网穿透frp及树莓派的应用/rpc-connect-setting.png" alt></p><p>  这是我在本地 127.0.0.1 打开后设置rpc,即可连接树莓派的 <strong>aria2</strong> 了  </p><p>  扯远了,假设现在是在手机端,没有安装连接 <strong>aria2</strong> rpc的软件,这时候就依旧用树莓派的就可以了,打开树莓派的http端口,因为做了端口映射,所以在浏览器输入 x.x.x.x:7003 就是了,<strong>webui-aria2</strong> 默认的rpc端口就是当前地址下的6800端口,但因为我们是做了端口映射处理,所以这里在 设置-连接设置处把rpc端口改为 7004 就可以了,如上图所示.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此,我们的树莓派就可以在何地何处都能远程添加下载任务了,并且我们映射了ssh的22端口出去,也可以远程通过ssh控制树莓派,perfect!</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派之下载机和NAS服务器</title>
      <link href="/2017/11/01/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E4%B8%8B%E8%BD%BD%E6%9C%BA%E5%92%8CNAS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/11/01/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B9%8B%E4%B8%8B%E8%BD%BD%E6%9C%BA%E5%92%8CNAS%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Q: 用树莓派搭建下载机的优势是什么<br>A: 树莓派耗电量极低,可以24小时挂机不费多少电费</p></blockquote><blockquote><p>Q: NAS局域云是什么<br>A: NAS全称是Network Attached Storage,即网络连接存储设备,通俗点讲就是云存储,可以让你在局域网内有个可以任意读写的网盘,在不同设备都可以访问.适合用来存储大文件或者电影等,从而在不同设备都可直接观看电影</p></blockquote><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手!"></a>开始动手!</h2><h3 id="搭建下载机"><a href="#搭建下载机" class="headerlink" title="搭建下载机"></a>搭建下载机</h3><p>在<a href="/2017/07/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E4%BD%93%E9%AA%8C/">树莓派初体验</a>一文已经提到烧录好了系统,因此下一步就是安装<strong>aria2</strong></p><blockquote><p><a href="https://aria2.github.io/" target="_blank" rel="noopener">aria2</a>是一个轻量级和多来源的命令行下载工具,aria2支持 HTTP/HTTPS, FTP, SFTP, BitTorrent 和 Metalink等协议.(注:不支持ed2k协议).</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code class="shell">sudo apt install aria2 </code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>aria2 安装后对应的命令不是aria2而是aria2c.<br>可以通过<code>man aria2c</code>查看使用手册<br>最简单的通过命令下载文件的例子如下</p><pre><code class="shell">aria2c http://example.org/mylinux.iso</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>aria2c是有很多命令选项的,我们可以把这些选项写成一个配置文件,在启动时候通过 <code>--conf-path=aria2.conf</code> 命令选项指定配置文件即可<br>下面是我自己用的配置文件,仅供参考</p><pre><code class="shell">#文件保存目录 dir=/home/feng/Downloads/aria2#因为垃圾运营商还没有ipv6，获取了也没有，关掉disable-ipv6=true  #打开rpc给等会的web管理界面用enable-rpc=true  rpc-allow-origin-all=true  rpc-listen-all=true  #rpc监听端口6800 缺省设置rpc-listen-port=6800  #允许断点续传continue=true  #进度保存文件input-file=/home/feng/opt/aria2/aria2.session  save-session=/home/feng/opt/aria2/aria2.session  #最大同时下载任务数max-concurrent-downloads=8</code></pre><p>详细配置文件选项可以参考<a href="https://gist.github.com/feng409/e52767790eb8f47016f5059bc7df44cc" target="_blank" rel="noopener">这里</a></p><h4 id="RPC-Remote-Procedure-Call-远程过程调用"><a href="#RPC-Remote-Procedure-Call-远程过程调用" class="headerlink" title="RPC(Remote Procedure Call)远程过程调用"></a>RPC(Remote Procedure Call)远程过程调用</h4><p>想必有人已经发现上面配置文件中有不少是关于rpc的,aria2是支持RPC远程调用的<br>通过rpc远程调用,我们可以使用一些web应用来远程调用aria2下载,不然每次都通过命令行调用多累啊.<br>github有不少大佬写好的web应用项目了,可以直接拿来用,安装也很简单.下面推荐下:</p><ul><li><strong><a href="https://github.com/ziahamza/webui-aria2" target="_blank" rel="noopener">webui-aria2</a></strong> 最多人使用的aria2 web应用.支持多国语言,中文汉化不完全,界面简洁</li><li><strong><a href="https://github.com/binux/yaaw" target="_blank" rel="noopener">yaaw</a></strong> 国产的另一个框架,不过官方不支持中文,github上有汉化版.界面不大喜欢</li><li><strong><a href="https://github.com/mayswind/AriaNg" target="_blank" rel="noopener">AriaNg</a></strong> 同国产的一个web ui项目,支持中文,在汉化方面应该是最好的一个了</li></ul><p>在这里以 <strong>webui-aria2</strong> 项目为例,在github上克隆项目源码后,直接将项目源码移动到网站目录下即可.而后打开本地网站即可看到.</p><pre><code class="bash">git clone https://github.com/ziahamza/webui-aria2 #克隆源码cd webui-aria2mv ./* /var/www/html/ # 默认网站目录</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><pre><code class="bash">aria2c  --conf-path=aria2.conf</code></pre><p>而后打开 <strong><em>127.0.0.1</em></strong> 即可看到了<br><img src="/2017/11/01/树莓派之下载机和NAS服务器/webui-aria2.png" alt></p><h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><p>每次都要输入这条命令多累啊,不仅麻烦还不好管理.因此,把它写作一个Unit,通过systemd来管理是最简单方便的了.下面附上自己写的一个简单的Unit服务.</p><pre><code class="bash"># sudo vim /usr/lib/systemd/system/aria2.service;=============================================================================;     FileName: aria2.service;         Desc: aria2 download;       Author: chemf;        Email: chemf01@163.com;     HomePage: ;      Version: 0.0.1;   LastChange: 2017-10-17 10:03:47;      History:;=============================================================================[Unit]Description=aria2 download service[Service]Type=simpleExecStart=/usr/bin/aria2c --conf-path=/home/feng/opt/aria2/aria2.conf # 这里的路径需要改为自己的[Install]WantedBy=multi-user.target</code></pre><p>现在,让我们结束刚才的进程并通过服务启动aria2吧,并让他开机自启</p><pre><code class="bash">sudo systemctl daemon-reload # 重载服务管理器配置,就是扫描获取到咱们刚写的服务sudo systemctl start aria2.service # 启动服务sudo systemctl enable aria2.service # 设置服务开机自启</code></pre><p>至此,我们的下载机部分完成了.</p><h3 id="搭建NAS服务"><a href="#搭建NAS服务" class="headerlink" title="搭建NAS服务"></a>搭建NAS服务</h3><h4 id="samba简介"><a href="#samba简介" class="headerlink" title="samba简介"></a>samba简介</h4><blockquote><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。 SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。                 –<a href="https://baike.baidu.com/item/Samba" target="_blank" rel="noopener">百度百科-samba</a></p></blockquote><blockquote><p>简而言之,Samba就是一个Linux上的共享服务器软件</p></blockquote><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><pre><code class="bash">sudo apt install samba  </code></pre><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>参考配置如下:  </p><pre><code class="bash">#vim /etc/samba/smb.conf#其他默认部分略#======================= Share Definitions =======================[custom_share] # 分享名comment = 这是说明 browseable = yes # 是否允许浏览查看path = /home/pi/Downloads # 分享目录create mask = 0750 # 创建文件默认掩码read only = yes # 只读guest ok = yes # 是否允许游客登录public = yes # 同上</code></pre><h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><pre><code class="bash">systemctl start smbd # 注意了,samba服务对应的是smbd</code></pre><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><ul><li>Windows 打开文件管理器,在地址栏输入 <code>\\ip\</code>即可</li><li>Android 可以下载ES文件管理器,支持查看smb局域网的文件,并在线播放</li><li>Linux 以Ubuntu为例,打开文件管理器,在 <code>Connect to Server</code> 输入 <code>smb://ip/</code>即可</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK,NAS和下载机搭建完成,但是这是仅限于局域网内控制的,如何在其他地点如公司远程提交下载任务呢,方法有二:  </p><ol><li>使用迅雷远程下载,需要编译使用迅雷开源的xware程序,麻烦,而且…官方支持很不友好,并且远程下载意味着咱们的aria2下载白费功夫了…</li><li>使用内网穿透,将树莓派的相关端口映射出去,如此,咱们就可以在公网上访问了,便可以控制提交远程下载了.详情请看下篇文章 <strong><a href="/2017/11/13/内网穿透frp及树莓派的应用/">内网穿透frp及树莓派的应用</a></strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ssh自动掉线问题</title>
      <link href="/2017/10/23/%E8%A7%A3%E5%86%B3ssh%E8%87%AA%E5%8A%A8%E6%8E%89%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2017/10/23/%E8%A7%A3%E5%86%B3ssh%E8%87%AA%E5%8A%A8%E6%8E%89%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>  ssh在一段时间没有操作输入时将会掉线,原因是 <strong>在防火墙中会有闲置超时断开</strong> 的默认机制<br>因此,在解决 <strong>闲置超时断开</strong> 问题,可以采用定时发送心跳包的方式解决</p><h3 id="服务器端解决方法"><a href="#服务器端解决方法" class="headerlink" title="服务器端解决方法:"></a>服务器端解决方法:</h3><pre><code class="shell"># /etc/ssh/sshd_configTCPKeepAlive yesClientAliveInterval 300ClientAliveCountMax 3</code></pre><p>在服务器端ssh配置文件添加上述内容.其中,<br><strong><em>TCPKeepAlice yes</em></strong> 表示TCP连接保持不断开<br><strong><em>ClientAliveInterval 300</em></strong> 表示每个300秒向客户端发送心跳包,然后等待客户度响应,成功则保持连接<br><strong><em>ClientAliveCountMax 3</em></strong> 表示客户端无响应的情况下最多尝试请求次数,超过则自动断开<br>最后,重启sshd服务:<br><code>sudo systemctl restart ssh.service</code></p><h3 id="客户端解决方法"><a href="#客户端解决方法" class="headerlink" title="客户端解决方法:"></a>客户端解决方法:</h3><ul><li>配置文件解决:<pre><code class="shell">  ServerAliveInterval 60  ServerAliveCountMax 3</code></pre>  <strong><em>ServerAliveInterval 60</em></strong> 表示每隔60秒向服务器端发送心跳包<br>  <strong><em>ServerAliveCountMax 3</em></strong> 表示无响应最多尝试次数  </li><li>连接参数解决:<br> <code>ssh -o ServerAliveInterval=30 user@host</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCF-201609-2</title>
      <link href="/2017/09/04/CCF-201609-2/"/>
      <url>/2017/09/04/CCF-201609-2/</url>
      
        <content type="html"><![CDATA[<td style="margin:0px; padding:12px; background:rgb(255,255,255); text-align:left"><br><div class="pdsec" style="margin:12px 0px 20px; padding:0px; font-weight:bold">问题描述</div><br><div class="pdcont" style="margin:0px 0px 0px 32px; padding:0px">　　请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。<br style="margin:0px; padding:0px"><br>　　假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。<br style="margin:0px; padding:0px"><br>　　购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。<br style="margin:0px; padding:0px"><br>　　假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。</div><br><div class="pdsec" style="margin:12px 0px 20px; padding:0px; font-weight:bold">输入格式</div><br><div class="pdcont" style="margin:0px 0px 0px 32px; padding:0px">　　输入的第一行包含一个整数n，表示购票指令的数量。<br style="margin:0px; padding:0px"><br>　　第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。</div><br><div class="pdsec" style="margin:12px 0px 20px; padding:0px; font-weight:bold">输出格式</div><br><div class="pdcont" style="margin:0px 0px 0px 32px; padding:0px">　　输出n行，每行对应一条指令的处理结果。<br style="margin:0px; padding:0px"><br>　　对于购票指令p，输出p张车票的编号，按从小到大排序。</div><br><div class="pdsec" style="margin:12px 0px 20px; padding:0px; font-weight:bold">样例输入</div><br><div class="pddata" style="margin:0px 0px 0px 32px; padding:0px; font-family:&quot;Courier New&quot;; font-size:16px"><br>4<br style="margin:0px; padding:0px"><br>2 5 4 2</div><br><div class="pdsec" style="margin:12px 0px 20px; padding:0px; font-weight:bold">样例输出</div><br><div class="pddata" style="margin:0px 0px 0px 32px; padding:0px; font-family:&quot;Courier New&quot;; font-size:16px"><br>1 2<br style="margin:0px; padding:0px"><br>6 7 8 9 10<br style="margin:0px; padding:0px"><br>11 12 13 14<br style="margin:0px; padding:0px"><br>3 4</div><br><div class="pdsec" style="margin:12px 0px 20px; padding:0px; font-weight:bold">样例说明</div><br><div class="pdcont" style="margin:0px 0px 0px 32px; padding:0px">　　1) 购2张票，得到座位1、2。<br style="margin:0px; padding:0px"><br>　　2) 购5张票，得到座位6至10。<br style="margin:0px; padding:0px"><br>　　3) 购4张票，得到座位11至14。<br style="margin:0px; padding:0px"><br>　　4) 购2张票，得到座位3、4。</div><br><div class="pdsec" style="margin:12px 0px 20px; padding:0px; font-weight:bold">评测用例规模与约定</div><br><div class="pdcont" style="margin:0px 0px 0px 32px; padding:0px">　　对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。</div><br></td><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><pre><code class="java">import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;/** * Created by feng on 17-9-4. */public class CCF_201609_2 {    public static void main(String[] args) throws FileNotFoundException {        Scanner scanner = new Scanner(new File(&quot;data&quot;));//        Scanner scanner = new Scanner(System.in);        int[] ticket = new int[100];        int[] shengyu = new int[20];//标记数组当前排剩余多少作为        for (int i = 0; i &lt; 20; i++) {            shengyu[i] = 5;        }        int n = scanner.nextInt();        for (int i = 0; i &lt; n; i++) {            int cmd = scanner.nextInt();            if (cmd &gt; 5){//剪枝操作,如果指令大于5就不需要遍历有没有连坐                int  j = 0;                while (cmd &gt; 0){                    if (ticket[j] != 1){                        ticket[j] = 1;                        System.out.print( (j+1) + &quot; &quot;);                        cmd--;                        shengyu[j/5]--;                    }                    i++;                }                System.out.println();                continue;            }            for (int k = 0; k &lt; 20; k++) {//遍历                if (shengyu[k] &gt;= cmd){                    shengyu[k] -= cmd;                    int j = k*5 ;                    while (cmd &gt; 0){                        if (ticket[j] != 1){                            ticket[j] = 1;                            System.out.print( (j+1) + &quot; &quot;);                            cmd--;                        }                        j++;                    }                }            }            int  j = 0;            while (cmd &gt; 0){//遍历不出来的话挨个放进去进去                if (ticket[j] != 1){                    ticket[j] = 1;                    System.out.print( (j+1) + &quot; &quot;);                    cmd--;                    shengyu[j/5]--;                }                i++;            }            System.out.println();        }    }}import java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;/** * Created by feng on 17-9-4. */public class Main{    public static void main(String[] args) throws FileNotFoundException {        Scanner scanner = new Scanner(System.in);        int[] ticket = new int[100];        int[] shengyu = new int[20];//标记数组当前排剩余多少作为        for (int i = 0; i &lt; 20; i++) {            shengyu[i] = 5;        }        int n = scanner.nextInt();        for (int i = 0; i &lt; n; i++) {            int cmd = scanner.nextInt();            if (cmd &gt; 5){//剪枝操作,如果指令大于5就不需要遍历有没有连坐                int  j = 0;                while (cmd &gt; 0){                    if (ticket[j] != 1){                        ticket[j] = 1;                        System.out.print( (j+1) + &quot; &quot;);                        cmd--;                        shengyu[j/5]--;                    }                    i++;                }                System.out.println();                continue;            }            for (int k = 0; k &lt; 20; k++) {//遍历                if (shengyu[k] &gt;= cmd){                    shengyu[k] -= cmd;                    int j = k*5 ;                    while (cmd &gt; 0){                        if (ticket[j] != 1){                            ticket[j] = 1;                            System.out.print( (j+1) + &quot; &quot;);                            cmd--;                        }                        j++;                    }                }            }            int  j = 0;            while (cmd &gt; 0){//遍历不出来的话挨个放进去进去                if (ticket[j] != 1){                    ticket[j] = 1;                    System.out.print( (j+1) + &quot; &quot;);                    cmd--;                    shengyu[j/5]--;                }                i++;            }            System.out.println();        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 竞赛刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CCF-201703-4</title>
      <link href="/2017/08/25/CCF-201703-4/"/>
      <url>/2017/08/25/CCF-201703-4/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>　　A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。<br>　　地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。<br>　　现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。<br>　　作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。  </p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。<br>　　第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。</p></blockquote><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>　　输出一个整数，修建整条地铁线路最少需要的天数。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>6 6<br>1 2 4<br>2 3 4<br>3 6 7<br>1 4 2<br>4 5 5<br>5 6 6  </p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>6</p><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><blockquote><p>　　可以修建的线路有两种。<br>　　第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完；<br>　　第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。<br>　　第二种方案所用的天数更少。<br>评测用例规模与约定<br>　　对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 20；<br>　　对于40%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000；<br>　　对于60%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000，1 ≤ c ≤ 1000；<br>　　对于80%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000；<br>　　对于100%的评测用例，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。  </p></blockquote><p>　　所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。  </p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h3><blockquote><p>一开始打算用最小生成树和并查集解,最小生成树的节点记录下一节点的下标和到下一节点的权重,生成树后搜索1号节点到n号节点经过的节点中的最大权重.超时失败.<br>剪枝优化:并查集进行路劲压缩,仅仅使用并查集解即可,按照<strong>Kruskal</strong>算法将边数组按照权重升序后,生成树时,每生成一个检查1号节点和n号节点是否在同一集合,是的话退出记录当前边的权重即为答案.  </p></blockquote><blockquote><p>70分非AC代码,怀疑是java运行慢的问题….<br><code>`</code>java<br>import java.io.File;<br>import java.io.FileNotFoundException;<br>import java.util.Arrays;<br>import java.util.Comparator;<br>import java.util.Scanner;</p></blockquote><p>public class Main {<br>    public static void main(String[] args) throws FileNotFoundException {<br>//        Scanner scanner = new Scanner(new File(“data”));<br>        Scanner scanner = new Scanner(System.in);<br>        int n = scanner.nextInt();<br>        int m = scanner.nextInt();<br>        Main main = new Main(n, m);<br>        for (int i = 0; i &lt; m; i++) {<br>            int start = scanner.nextInt();<br>            int end = scanner.nextInt();<br>            int weight = scanner.nextInt();<br>            main.addEdge(i, start, end, weight);<br>        }<br>        main.spanningTree();<br>        System.out.print(main.max);<br>    }</p><pre><code>private Edge edges[];private int node[];private int n;public int max;private int find(int n){    while ( n != node[n]){        n = find(node[n]);    }    return n;}private void spanningTree(){    Arrays.sort(edges, new Comparator&lt;Edge&gt;() {        @Override        public int compare(Edge o1, Edge o2) {            return o1.weight - o2.weight;        }    });    for (int i = 0; i &lt; edges.length; i++) {        int a = find(edges[i].start);        int b = find(edges[i].end);        if (b != a){            if (a &lt; b){                node[b] = a;            }else {                node[a] = b;            }            this.max = edges[i].weight;        }        if (find(this.n) == 1) return;    }}public Main(int n, int m) {    this.n = n;    node = new int[n+1];    for (int i = 0; i &lt; n + 1; i++) {        node[i] = i;    }    edges = new Edge[m];}public void addEdge(int i, int start, int end, int weight){    edges[i] = new Edge(start, end, weight);}</code></pre><p>}</p><p>class Edge{<br>    int start;<br>    int end;<br>    int weight;</p><pre><code>public Edge(int start, int end, int weight) {    this.start = start;    this.end = end;    this.weight = weight;}</code></pre><p>}</p><p><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> 竞赛刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CCF-201703-2</title>
      <link href="/2017/08/24/CCF-201703-2/"/>
      <url>/2017/08/24/CCF-201703-2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。<br>　　例如，下面给出了一组移动的例子，例子中学生的人数为8人。<br>　　0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8；<br>　　1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8；<br>　　2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7；<br>　　3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。<br>　　小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？<br>　　请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>　　输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。<br>　　第二行包含一个整数m，表示调整的次数。<br>　　接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>　　输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>8<br>3<br>3 2<br>8 -3<br>3 -2  </p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>1 2 4 3 5 8 6 7  </p><h3 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h3><p>　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><blockquote><p>可以使用链式队列,嗯…移动元素算是插队行为吧…</p></blockquote><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="java">public class Main {    private List&lt;Integer&gt; list;    public Main(int n) {        this.list = new LinkedList&lt;Integer&gt;();        for (int i = 1 ; i &lt;= n ; i++){            this.list.add(i);        }    }    @Override    public String toString() {        StringBuffer sb = new StringBuffer();        for (int i : this.list) {            sb.append(i);            sb.append(&quot; &quot;);        }        return sb.deleteCharAt(sb.length()-1).toString();    }    public void f(int p, int q){        int position = this.list.indexOf(p);        this.list.remove(new Integer(p));        this.list.add(position + q, p);    }    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        int n = scanner.nextInt();        Main main = new Main(n);        int m = scanner.nextInt();        while ( m-- &gt; 0){            int p = scanner.nextInt();            int q = scanner.nextInt();            main.f(p, q);        }        System.out.println(main.toString());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 竞赛刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决systemd下tmux和screen无法后台执行命令</title>
      <link href="/2017/08/20/%E8%A7%A3%E5%86%B3systemd%E4%B8%8Btmux%E5%92%8Cscreen%E6%97%A0%E6%B3%95%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/08/20/%E8%A7%A3%E5%86%B3systemd%E4%B8%8Btmux%E5%92%8Cscreen%E6%97%A0%E6%B3%95%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>&emsp;&emsp;目前大多数Linux发行版已经使用<code>systemd</code>启动代替以前的<code>init</code>启动，在<code>systemd</code>下，默认会话结束时，会杀死的会话中的所有进程。  </p><p>&emsp;&emsp;因此当远程ssh时<code>exit</code>后<code>screen</code>和<code>tmux</code>的会话窗口也被关闭了。   </p><a id="more"></a><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>&emsp;&emsp;在systemd启动下，由<code>loginctl</code>控制着用户登录的一些配置选项。例如用户 <strong>log out</strong> 时默认杀死用户所有进程。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul><li><p>方法一：修改<code>loginctl</code>默认配置</p><pre><code class="bash">  #/etc/systemd/logind.conf  KillUserProcesses=no</code></pre><p>  然后重启服务即可</p><pre><code class="bash">  sudo systemctl restart systemd-logind</code></pre></li><li><p>方法二：运行命令在当前用户session外，使用<code>systemd-run</code>命令：</p><pre><code class="bash">  systemd-run --user --scope tmux</code></pre><p>  <code>systemd-run</code>用于后台执行命令，将进程从当前用户归属于<code>systemd</code>用户</p></li><li><p>方法三：将命令写成一个服务，通过服务启动  </p><blockquote><p>例如将scrapyd命令作为服务单元启动</p></blockquote><pre><code class="bash">  #/usr/lib/systemd/system/scrapyd.service  [Unit]  Description=run the Scrapyd server  [Service]  ExecStart=/home/pi/.virtualenvs/python3/bin/scrapyd  Type=simple  KillMode=process  [Install]  WantedBy=multi-user.target</code></pre><p> 而后执行命令即可:</p><pre><code class="bash"> sudo systemctl daemon-reload sudo systemctl start scrapyd</code></pre><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4></li><li><p><a href="https://www.freedesktop.org/software/systemd/man/logind.conf.html#KillUserProcesses=" target="_blank" rel="noopener">logind.conf配置选项说明</a></p></li><li><p><a href="https://www.freedesktop.org/software/systemd/man/loginctl.html#" target="_blank" rel="noopener">loginctl命令介绍</a></p></li><li><p><a href="https://www.freedesktop.org/software/systemd/man/systemd-run.html#" target="_blank" rel="noopener">systemd-run命令介绍</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程：命令篇 (阮一峰)</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">Systemd 入门教程：实战篇 (阮一峰)</a></p></li><li><p><a href="https://askubuntu.com/questions/802189/how-to-run-tmux-screen-with-systemd-230" target="_blank" rel="noopener">How to run tmux/screen with systemd &gt; 230?</a></p></li><li><p><a href="https://segmentfault.com/q/1010000010749413?_ea=2403416" target="_blank" rel="noopener">树莓派kali系统screen和nohup不能后台运行</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel默认登录注册源码解析追踪</title>
      <link href="/2017/08/18/laravel%E9%BB%98%E8%AE%A4%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%BF%BD%E8%B8%AA/"/>
      <url>/2017/08/18/laravel%E9%BB%98%E8%AE%A4%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<p>  被laravel的登录注册烦恼了好一段时间，总算理顺了思路。<br><a id="more"></a><br>laravel内部封装实现好了一个简单版本的登录注册模块，通过以下命令即可快速开启:</p><pre><code class="bash">php artisan make:auth</code></pre><p>但是毕竟是默认实现好的，总想知道内部代码实现。于是开始了源码之旅。。。</p><h4 id="Auth"><a href="#Auth" class="headerlink" title="Auth"></a>Auth</h4><p>先说说laravel的认证过程，门面(Facade) <strong>Auth</strong> 提供了一些便捷的方法如获得当前认证用户信息等，实际上负责认证用户的是守卫 <strong>guard</strong> ，guard负责该用户是否通过验证，是否已登录，是否 <code>记住</code>等。<strong>门面Auth实际上是在   <code>AuthServiceProvider</code> 中注册的 <code>AuthManager</code> 的实例</strong></p><h4 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h4><p>关于<strong>guard</strong>的配置在config/Auth.php中，如配置默认使用哪个 <strong>guard</strong> ， <strong>guard</strong> 使用的驱动，框架默认实现的有 <code>session</code> 和 <code>token</code>  两个驱动类。驱动类则负责从服务提供类中获得认证需要的数据。</p><pre><code>    &#39;guards&#39; =&gt; [        &#39;web&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;session&#39;,            &#39;provider&#39; =&gt; &#39;users&#39;,        ],        &#39;api&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;token&#39;,            &#39;provider&#39; =&gt; &#39;users&#39;,        ],    ],</code></pre><p>自定义guard类，guard需要检查用户是否登录，认证账号是否正确等，因此laravel定义了一个契约接口需要实现，自定义guard需要<code>StatefulGuard</code>或者<code>Guard</code>接口。然后在 <strong>AuthServiceProvider</strong> 中注册guard。</p><pre><code class="php">class AuthServiceProvider extends ServiceProvider{    /**     * Register any application authentication / authorization services.     *     * @return void     */    public function boot()    {        $this-&gt;registerPolicies();        // &#39;jwt&#39;为注册guard的名字，待会在config/auth.php中配置。        // 匿名函数返回自定义的guard类的实例        Auth::extend(&#39;jwt&#39;, function ($app, $name, array $config) {            // Return an instance of Illuminate\Contracts\Auth\Guard...            return new JwtGuard(Auth::createUserProvider($config[&#39;provider&#39;]));        });    }}</code></pre><p>注册后需要在config/auth.php中配置</p><pre><code>&#39;guards&#39; =&gt; [    &#39;api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;jwt&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],],</code></pre><h4 id="providers"><a href="#providers" class="headerlink" title="providers"></a>providers</h4><p><strong>guard</strong> 负责认证用户，具体为针对请求中的认证信息，对对应数据库中的信息查询是否存在，而查询信息这种操作便是交给服务提供者来实现了。在默认配置中，设定了 ‘web’ 这个 <strong>guard</strong> 的提供者为 <code>users</code> 。 下面是 <code>users</code> 的配置。</p><pre><code>    &#39;providers&#39; =&gt; [        &#39;users&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39; =&gt; App\User::class,        ],</code></pre><p><code>users</code>使用 <code>eloquent</code>驱动，默认的驱动支持<code>eloquent</code>和<code>database</code>。这里使用 <code>eloquent</code>驱动，<code>eloquent</code>对应使用的model类是<code>App\User:class</code>，即认证用户在user表中。</p><p>自定义provider，自定义类需要实现 <strong>UserProvider</strong> 接口，接口定义了如下方法需要实现:</p><ul><li>retrieveById : 获取一个代表用户的值</li><li>retrieveByToken : 借助用户唯一的 <strong>$identifier</strong> 和「记住我」<strong>$token</strong> 来获取用户</li><li>updateRememberToken : 使用新的 <strong>$token</strong> 更新 <strong>$user</strong> 的 <strong>remember_token</strong> 字段</li><li>retrieveByCredentials : 根据凭证数据获取一个 <strong>UserInterface</strong> 的实例。</li><li>validateCredentials ： 比较 $user 和 $credentials 来认证这个用户。<br>如上接口laravel也封装好了默认的实现类，分别是 <code>EloquentUserProvider</code> 和 <code>DatabaseUserProvider</code> 。当providers配置驱动(driver)为 ‘eloquent’ 时即为前者，配置驱动为 ‘database’ 时使用后者。可以查看这两个类源码看具体接口实现。</li></ul><p>自定义providers的注册与配置，自定义好providers后在AuthServiceProvider的boot方法中注册</p><pre><code>class AuthServiceProvider extends ServiceProvider{    /**     * Register any application authentication / authorization services.     *     * @return void     */    public function boot()    {        $this-&gt;registerPolicies();        Auth::provider(&#39;riak&#39;, function ($app, array $config) {            return new RiakUserProvider($app-&gt;make(&#39;riak.connection&#39;));        });    }}</code></pre><p>而后在config/auth.php中配置</p><pre><code>    &#39;providers&#39; =&gt; [        &#39;users&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;riak&#39;,            &#39;model&#39; =&gt; App\User::class,        ],</code></pre><h4 id="自定义Model。"><a href="#自定义Model。" class="headerlink" title="自定义Model。"></a>自定义Model。</h4><p>自定义model需要实现接口 <strong>Illuminate\Contracts\Auth\Authenticatable</strong>  </p><p>系统默认实现好了一个 <strong>User</strong> model类，并使用trait  <strong>Illuminate\Auth\Authenticatable</strong> 实现接口了接口中的方法，当自定义时可以在源码实现中参考。</p><hr><h3 id="登录认证过程"><a href="#登录认证过程" class="headerlink" title="登录认证过程"></a>登录认证过程</h3><p>讲完上面的基础知识后，看一遍laravel生成的登录认证过程吧！</p><p>当使用命令 <code>php artisan make:auth</code>后，系统会生成了一些脚手架。首先是routes/web.php中，增加了一些路由如下:</p><pre><code>Auth::routes();Route::get(&#39;/&#39;, &#39;HomeController@index&#39;)-&gt;name(&#39;home&#39;);</code></pre><p>跟中源码可得,Auth::routes()实际上是调用Illuminate/Routing/Router类的auth方法.</p><pre><code class="php">    /**     * Register the typical authentication routes for an application.     *     * @return void     */    public function auth()    {        // Authentication Routes...        $this-&gt;get(&#39;login&#39;, &#39;Auth\LoginController@showLoginForm&#39;)-&gt;name(&#39;login&#39;);        $this-&gt;post(&#39;login&#39;, &#39;Auth\LoginController@login&#39;);        $this-&gt;post(&#39;logout&#39;, &#39;Auth\LoginController@logout&#39;)-&gt;name(&#39;logout&#39;);        // Registration Routes...        $this-&gt;get(&#39;register&#39;, &#39;Auth\RegisterController@showRegistrationForm&#39;)-&gt;name(&#39;register&#39;);        $this-&gt;post(&#39;register&#39;, &#39;Auth\RegisterController@register&#39;);        // Password Reset Routes...        $this-&gt;get(&#39;password/reset&#39;, &#39;Auth\ForgotPasswordController@showLinkRequestForm&#39;)-&gt;name(&#39;password.request&#39;);        $this-&gt;post(&#39;password/email&#39;, &#39;Auth\ForgotPasswordController@sendResetLinkEmail&#39;)-&gt;name(&#39;password.email&#39;);        $this-&gt;get(&#39;password/reset/{token}&#39;, &#39;Auth\ResetPasswordController@showResetForm&#39;)-&gt;name(&#39;password.reset&#39;);        $this-&gt;post(&#39;password/reset&#39;, &#39;Auth\ResetPasswordController@reset&#39;);    }</code></pre><p>而后进行登录操作，跳转到Auth\LoginController的showLoginForm方法。</p><blockquote><p>在LoginController中会发现没有showLoginForm方法，该类使用了<code>AuthenticatesUsers</code>这个trait实现了Auth::routes()路由中LoginController的方法。</p></blockquote><p>showLoginForm方法如下:</p><pre><code class="php">    /**     * Show the application&#39;s login form.     *     * @return \Illuminate\Http\Response     */    public function showLoginForm()    {        return view(&#39;auth.login&#39;);    }</code></pre><p>返回默认生成的login视图，login视图的表单中有一行代码为</p><pre><code>&lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot; method=&quot;POST&quot; action=&quot;{{ route('login') }}&quot;&gt;</code></pre><p>即表单账号数据post到路由login中，回到web.php可以看到post到login对应的方法的为Auth\LoginController的login方法。方法源码如下。</p><pre><code class="php">    /**     * Handle a login request to the application.     *     * @param  \Illuminate\Http\Request  $request     * @return \Illuminate\Http\RedirectResponse|\Illuminate\Http\Response     */    public function login(Request $request)    {        $this-&gt;validateLogin($request);        // If the class is using the ThrottlesLogins trait, we can automatically throttle        // the login attempts for this application. We&#39;ll key this by the username and        // the IP address of the client making these requests into this application.        if ($this-&gt;hasTooManyLoginAttempts($request)) {            $this-&gt;fireLockoutEvent($request);            return $this-&gt;sendLockoutResponse($request);        }        if ($this-&gt;attemptLogin($request)) {            return $this-&gt;sendLoginResponse($request);        }        // If the login attempt was unsuccessful we will increment the number of attempts        // to login and redirect the user back to the login form. Of course, when this        // user surpasses their maximum number of attempts they will get locked out.        $this-&gt;incrementLoginAttempts($request);        return $this-&gt;sendFailedLoginResponse($request);    }</code></pre><p>首先是<code>$this-&gt;validateLogin($request);</code>,源码为：</p><pre><code class="php">    /**     * Validate the user login request.     *     * @param  \Illuminate\Http\Request  $request     * @return void     */    protected function validateLogin(Request $request)    {        $this-&gt;validate($request, [            $this-&gt;username() =&gt; &#39;required|string&#39;,            &#39;password&#39; =&gt; &#39;required|string&#39;,        ]);    }</code></pre><p>即验证用户的请求中用户的表单填写是否正确，这里的验证规则是 <code>$this-&gt;username</code>和<code>password</code>字段必须是非空且是string类型。<br>如果验证规则不通过，将会抛出<code>ValidationException</code>异常，也就停止了login()函数往下走了。<code>$this-&gt;username</code>字段值默认是<code>email</code>,可以在LoginController中重写username()方法，返回别的字段名如<code>user_name</code>。</p><p>回到login()函数，当验证规则通过后，login函数往下走，</p><pre><code class="php">        if ($this-&gt;hasTooManyLoginAttempts($request)) {            $this-&gt;fireLockoutEvent($request);            return $this-&gt;sendLockoutResponse($request);        }</code></pre><p>判断该请求是否多次登录尝试，laravel有多次登录尝试时锁定一分钟不能登录的机制，这里跳过继续往下走。</p><pre><code class="php">        if ($this-&gt;attemptLogin($request)) {            return $this-&gt;sendLoginResponse($request);        }</code></pre><p>尝试登录。登录成功则发送登录成功响应。不过不成功，login函数往下走，增加这个请求的登录尝试次数，上文提到当多次请求将被锁定。最后发送登录失败响应。</p><p>回到attemptLogin方法，</p><pre><code class="php">    /**     * Attempt to log the user into the application.     *     * @param  \Illuminate\Http\Request  $request     * @return bool     */    protected function attemptLogin(Request $request)    {        return $this-&gt;guard()-&gt;attempt(            $this-&gt;credentials($request), $request-&gt;has(&#39;remember&#39;)        );    }</code></pre><p>调用门卫Guard进行登录尝试。这里的<code>$this-&gt;guard()</code>方法的实现是<code>return Auth::guard();</code>,再跳转到Auth::guard()方法，</p><pre><code class="php">    /**     * Attempt to get the guard from the local cache.     *     * @param  string  $name     * @return \Illuminate\Contracts\Auth\Guard|\Illuminate\Contracts\Auth\StatefulGuard     */    public function guard($name = null)    {        $name = $name ?: $this-&gt;getDefaultDriver();        return isset($this-&gt;guards[$name])                    ? $this-&gt;guards[$name]                    : $this-&gt;guards[$name] = $this-&gt;resolve($name);    }</code></pre><p>这里获取配置中配置使用的guard，由于不指定，所以按照config/auth.php配置后默认使用的是<code>web</code>这个guard，<code>web</code> guard配置的driver是 <code>session</code>,所以回到上文，<code>$this-&gt;guard()-&gt;attempt()</code>方法实际上调用的是 <strong>SessionGuard</strong> 类中的<code>attempt</code>方法。</p><pre><code class="php">    /**     * Attempt to authenticate a user using the given credentials.     *     * @param  array  $credentials     * @param  bool   $remember     * @return bool     */    public function attempt(array $credentials = [], $remember = false)    {        $this-&gt;fireAttemptEvent($credentials, $remember);        $this-&gt;lastAttempted = $user = $this-&gt;provider-&gt;retrieveByCredentials($credentials);        // If an implementation of UserInterface was returned, we&#39;ll ask the provider        // to validate the user against the given credentials, and if they are in        // fact valid we&#39;ll log the users into the application and return true.        if ($this-&gt;hasValidCredentials($user, $credentials)) {            $this-&gt;login($user, $remember);            return true;        }        // If the authentication attempt fails we will fire an event so that the user        // may be notified of any suspicious attempts to access their account from        // an unrecognized user. A developer may listen to this event as needed.        $this-&gt;fireFailedEvent($user, $credentials);        return false;    }</code></pre><p>第一行发送事件跳过，第二行<code>$this-&gt;lastAttempted = $user = $this-&gt;provider-&gt;retrieveByCredentials($credentials);</code>通过provider的<code>retrieveByCredentials</code>方法根据请求中携带的凭证获得Model的实例对象。这里根据在 <strong>config/auth.php</strong> 中的配置，跳转到 <strong>EloquentUserProvider</strong> 的 <code>retrieveByCredentials</code> 方法。</p><pre><code class="php">    /**     * Retrieve a user by the given credentials.     *     * @param  array  $credentials     * @return \Illuminate\Contracts\Auth\Authenticatable|null     */    public function retrieveByCredentials(array $credentials)    {        if (empty($credentials)) {            return;        }        // First we will add each credential element to the query as a where clause.        // Then we can execute the query and, if we found a user, return it in a        // Eloquent User &quot;model&quot; that will be utilized by the Guard instances.        $query = $this-&gt;createModel()-&gt;newQuery();        foreach ($credentials as $key =&gt; $value) {            if (! Str::contains($key, &#39;password&#39;)) {                $query-&gt;where($key, $value);            }        }        return $query-&gt;first();    }</code></pre><p>获得User这个model的查询构造器后根据凭证里面的键值对查询数据库中是否存在该对象，查询时不比对 <code>password</code> ，因为该字段在后面验证账号时才比对。</p><p>然后attempt方法往下走，</p><pre><code class="php">    public function attempt(array $credentials = [], $remember = false)    {        // 省略        if ($this-&gt;hasValidCredentials($user, $credentials)) {            $this-&gt;login($user, $remember);            return true;        }        // 省略    }        /**     * Determine if the user matches the credentials.     *     * @param  mixed  $user     * @param  array  $credentials     * @return bool     */    protected function hasValidCredentials($user, $credentials)    {        return ! is_null($user) &amp;&amp; $this-&gt;provider-&gt;validateCredentials($user, $credentials);    }</code></pre><p>根据凭证获得User这个模型的对象实例后，在 <code>hasValidCredentials</code> 方法判断实例是否为空，因为假设凭证数据在查询构造器中没有获得实例对象说明不存在这个数据。当 <code>$user</code> 不为空，在 <code>validateCredentials</code> 中，判断密码是否正确。</p><pre><code class="php">    public function validateCredentials(UserContract $user, array $credentials)    {        $plain = $credentials[&#39;password&#39;];        return $this-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword());    }</code></pre><p>在源码中可以看到默认的登录注册是将提交的密码hash加密后再与数据库中的 <code>$user</code> 对象的 <code>getAuthPassword()</code> 比较。 <code>getAuthPassword()</code> 的实现在 <code>Illuminate\Auth\Authenticatable</code> 如下。</p><pre><code class="php">    public function getAuthPassword()    {        return $this-&gt;password;    }</code></pre><p>回到attempt函数，当认证通过后，调用login函数，login函数主要做以下几件事：</p><pre><code class="php">    /**     * Log a user into the application.     *     * @param  \Illuminate\Contracts\Auth\Authenticatable  $user     * @param  bool  $remember     * @return void     */    public function login(AuthenticatableContract $user, $remember = false)    {        $this-&gt;updateSession($user-&gt;getAuthIdentifier());        // If the user should be permanently &quot;remembered&quot; by the application we will        // queue a permanent cookie that contains the encrypted copy of the user        // identifier. We will then decrypt this later to retrieve the users.        if ($remember) {            $this-&gt;ensureRememberTokenIsSet($user);            $this-&gt;queueRecallerCookie($user);        }        // If we have an event dispatcher instance set we will fire an event so that        // any listeners will hook into the authentication events and run actions        // based on the login and logout events fired from the guard instances.        $this-&gt;fireLoginEvent($user, $remember);        $this-&gt;setUser($user);    }</code></pre><ul><li>更新session</li><li>如果登录时有勾选 <code>Remember me</code> 选框，<ul><li>生成一个token Id存储到 <code>User</code> 表中</li><li>生成一个<code>remember me</code>的id到cookies中，据说是永久有效</li></ul></li><li>发送登录事件。</li></ul><hr><h3 id="注册认证过程"><a href="#注册认证过程" class="headerlink" title="注册认证过程"></a>注册认证过程</h3><p>注册的处理方法为 <code>RegisterController@register</code> 方法，同理在 trait <code>RegistersUsers</code>下。</p><pre><code class="php">    /**     * Handle a registration request for the application.     *     * @param  \Illuminate\Http\Request  $request     * @return \Illuminate\Http\Response     */    public function register(Request $request)    {        $this-&gt;validator($request-&gt;all())-&gt;validate();        event(new Registered($user = $this-&gt;create($request-&gt;all())));        $this-&gt;guard()-&gt;login($user);        return $this-&gt;registered($request, $user)                        ?: redirect($this-&gt;redirectPath());    }</code></pre><p>注册则较为简单，第一行先根据表单填写是否符合规则，规则在  <code>RegisterController@validator</code> 下，当表单填写通过规则后，调用  <code>RegisterController@create</code> 方法在数据库中添加一行数据。而后调用 <code>SessionGuard@login</code> 方法，在上面分析过了。</p><hr><p>至此，登录注册认证过程源码追踪解析完毕！</p>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信表情包电脑备份</title>
      <link href="/2017/07/23/%E5%BE%AE%E4%BF%A1%E8%A1%A8%E6%83%85%E5%8C%85%E7%94%B5%E8%84%91%E5%A4%87%E4%BB%BD/"/>
      <url>/2017/07/23/%E5%BE%AE%E4%BF%A1%E8%A1%A8%E6%83%85%E5%8C%85%E7%94%B5%E8%84%91%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="起因："><a href="#起因：" class="headerlink" title="起因："></a>起因：</h3><p>一次偶然用Windows的情况下，登录微信后发现微信的表情包自动同步后在<code>文档/WeChat Files/账号/CustomEmotions</code>下，文件名是32位字母数字组合.<br><img src="/2017/07/23/微信表情包电脑备份/微信_1.png" alt></p><h3 id="简单还原图片"><a href="#简单还原图片" class="headerlink" title="简单还原图片:"></a>简单还原图片:</h3><p>进入当前文件夹下的cmd窗口，执行批量重命名命令</p><pre><code class="dos"> ren &quot;*&quot; &quot;*.jpg&quot;</code></pre><blockquote><p>参数详解:</p><ul><li>ren 批量重命名命令</li><li>“*” 匹配所有文件</li><li>“*.jpg” 重命名所有文件加后缀名.jpg</li></ul></blockquote><p>效果如下：<img src="/2017/07/23/微信表情包电脑备份/微信_2.png" alt></p><h3 id="识别gif并自动根绝文件类型重命名"><a href="#识别gif并自动根绝文件类型重命名" class="headerlink" title="识别gif并自动根绝文件类型重命名"></a>识别gif并自动根绝文件类型重命名</h3><p>从上面的示例可以看出，这些没有文件后缀的文件其实是某一类型的文件。因此表情包除了静态图还有动态图，把动态图命名为jpg静态图无疑是不好的。因此，需要自动识别命名gif图。<br><del>事实上，文件名后缀只是作为操作系统识别文件的一种标志，并不能改变文件内部的信息。扩展名为jpg的文件也可能是一个扩展为sh的脚本文件。扯远了</del>  </p><p>在Linux下，file命令可以自动识别文件的类型。  </p><p><img src="/2017/07/23/微信表情包电脑备份/微信_3.png" alt><br>没错，这里是要用这个命令来重命名。简单写了个Python脚本如下：</p><pre><code class="python">&#39;&#39;&#39;# =============================================================================#      FileName: rename.py#          Desc: 根据文件类型自动文件名加后缀文件类型#        Author: chemf#         Email: chemf01@163.com#      HomePage: #       Version: 0.0.1#    LastChange: 2017-07-23 23:34:14#       History:# =============================================================================&#39;&#39;&#39;import osdata = os.popen(&#39;file `ls`&#39;)#列出当前目录下的所有文件的文件类型pwd = os.getcwd()for i in data:    old_name = i.split()[0][:-1]    new_name = old_name + &#39;.&#39; + i.split()[1]    os.rename(os.path.join(pwd, old_name), os.path.join(pwd, new_name))</code></pre><p>把脚本放到<code>CustomEmotions</code>目录下并执行<code>python3 rename.py</code>即可</p><blockquote><p>存在问题，脚本是Linux下的，需要Linux环境。。。不管了。大不了用Windows下的<strong>windows subsystem for linux</strong>吧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲扯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql字符集总结</title>
      <link href="/2017/07/13/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/2017/07/13/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li>查看数据库支持的字符集:<br><code>SHOW CHARACTER SET;</code></li><li><p>查看数据库当前使用的字符集:<br><code>SHOW VARIABLES LIKE &#39;%char%&#39;;</code></p><blockquote><p>各字段含义<br><img src="/2017/07/13/mysql字符集总结/character_set.png" alt><br>注：Linux下默认字符集是latin1，不支持中文。</p></blockquote></li><li><p>修改数据库字符集:<br><code>alter database database_name character set xxx;</code></p></li><li>修改表字符集:<br><code>alter table table_name character set xxx；</code></li><li>修改表字符集的同时转换已有列字符集:<br><code>alter table table_name convert to character set xxx;</code></li><li><p>修改列字符集  </p><pre><code> ALTER TABLE table_name MODIFY  column_name {CHAR | VARCHAR | TEXT} (column_length)  [CHARACTER SET charset_name]  [COLLATE collation_name]</code></pre><p><code>`</code></p></li><li><p>字符集校对规则(COLLATION)</p><blockquote><p>在字符集内部进行字符比较的规则，如大小写敏感等</p></blockquote></li><li><p>字符集校对规则特征:</p><ol><li>两个不同的字符集不能有相同的校对规则</li><li>每个字符集有一个默认校对规则</li><li>存在校对规则命名约定：以其相关的字符集名开始，中间包括一个语言名，并且以_ci（大小写不敏感）、_cs（大小写敏感）或_bin（二元）结束。  </li></ol></li><li><p>修改数据库默认字符集方法：</p><ul><li><code>set variable_name=character_set</code><br>eg: <code>set character_set_database=utf8mb4</code><blockquote><p>这种方法设置的字符集仅在此次连接，回话有效，重启后恢复默认</p></blockquote></li><li>在my.cnf配置文件设置字符集默认参数<pre><code class="bash">[client]# 设置客户端字符集default-character-set = utf8mb4[mysqld]# 设置服务端默认字符集character-set-server = utf8mb4# 设置服务端字符集默认校对规则collation-server = utf8mb4_unicode_ci# 设置拒绝客户端发送的字符集设置信息，即以服务端设置的字符集为准，可以防止客户端误操作character-set-client-handshake = FALSE</code></pre>注：在MySQL5.5.3之前，字符集在my.cnf中的配置为：<blockquote><p>[mysqd]<br>default-character-set=utf8mb4<br>但是在5.5.3中弃用了这个属性，详见<a href="http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_default-character-set" target="_blank" rel="noopener">文档</a></p></blockquote></li></ul></li><li><p>注：emoji表情为四个字节，而utf8是三个字节的，因此用utf8存储emoji表情会报错 <code>Incorrect string value: &#39;\xF0\x9F\x98\x84\xF0\x9F</code>，必须用utf8mb4，utf8mb4是用四个字节存储</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派初体验</title>
      <link href="/2017/07/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2017/07/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-烧录系统"><a href="#1-烧录系统" class="headerlink" title="1.  烧录系统"></a>1.  烧录系统</h3><ol><li><p>Linux</p><pre><code class="bash">sudo fdisk -l #找出microSD卡所在的设备位置 我这里是 /dev/sdcumount 挂载的目录 #必须先卸载U盘，是卸除挂载，不是拔除sudo dd if=树莓派.img of=/dev/sdc bs=4M # if参数是指树莓派img文件所在的路径，of是microSD卡所在的设备位置。  bs参数是每次传输的块大小</code></pre></li><li><p>Windows</p></li></ol><ul><li>使用<a href="https://www.sdcard.org/downloads/formatter_4/" target="_blank" rel="noopener">SDFormats</a>软件格式化TF卡</li><li>使用<a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">win32diskimager</a>软件将镜像拷贝进TF卡  </li></ul><h3 id="2-ssh连接"><a href="#2-ssh连接" class="headerlink" title="2. ssh连接"></a>2. ssh连接</h3><ul><li>首先是设置树莓派自动连接WiFi，在TF卡插入树莓派之前，在TF卡中etc分区添加以下信息<pre><code class="bash">#/etc/wpa_supplicant/wpa_supplicant.conf# 最常用的配置。WPA-PSK 加密方式。不需要删除文件其他东西，增加下面的即可network={ssid=&quot;WiFi-name1&quot;#WiFi名字psk=&quot;WiFi-password1&quot;#密码priority=5#权重，当存在多个可连接WiFi时按权重优先}</code></pre></li><li>这里烧录的是树莓派的官方镜像<code>raspbian</code>，这里有个小小的坑，<strong>自 2016-11-25 官方发布的 Raspbian 系统镜像，系统默认禁用了 SSH 服务。</strong>,因此开机后<code>service ssh restart</code>即可使用ssh，或者拔出TF卡，在boot分区里面创建一个文件名为ssh的空白文件即可，<code>touch ssh</code>.<blockquote><p>注:raspbian默认账号:<br>用户名:pi<br>密码:raspbian</p></blockquote></li></ul><h3 id="3-更新软件源"><a href="#3-更新软件源" class="headerlink" title="3. 更新软件源"></a>3. 更新软件源</h3><blockquote><p>装完Linux后一般都是换国内镜像源，可以提高软件源里面软件下载速度。因此装完系统第一步自然是换源了  </p></blockquote><p>raspbian和Ubuntu一样是基于debian的，因此也是使用apt作为包管理器，但是raspbian除了apt的镜像源之外，还有一个自家的raspi的镜像源，在<code>/etc/apt/source.d/raspi.list</code>下，因此换源要两个都换。找了半天后配置源如下</p><pre><code class="bash">#/etc/apt/source.listdeb http://mirrors.opencas.cn/raspbian/raspbian/ jessie contrib firmware main non-free rpideb-src http://mirrors.opencas.cn/raspbian/raspbian/ jessie contrib firmware main non-free rpi</code></pre><pre><code class="bash">#/etc/apt/source.d/raspi.listdeb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ jessie main uideb-src http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ jessie main ui</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin踩坑</title>
      <link href="/2017/05/26/kotlin%E8%B8%A9%E5%9D%91/"/>
      <url>/2017/05/26/kotlin%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>主要总结在学些kotlin时候遇到的一些新概念(每学习一门语言总会遇到一些新概念的冲击),以及一些个人的理解，以下按照文档中的内容总结。</p><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><ul><li>kotlin中一切都是对象，包括基本类型，这是因为基本类型会被进行了装箱操作<a href="#1">[1]</a>。  </li><li>和Java的转换：当定义变量为 <code>val a:Int?</code>时，在Java中显示a为integer对象，当定义变量<code>val a = 4</code> 时,在Java中为int变量</li><li>kotlin中用数据类Array<t>来表示不同类型的数组，创建并初始化数据。通过这种方式创建的成员在Java中调用的时候都是显示为对象类型，即进行了装箱操作，如果不想进行装箱操作则用<code>intArrayOf</code> <code>doubleArrayOf</code>等库函数</t></li><li>字符串面值：kotlin多了一个<code>&quot;&quot;&quot;&quot;&quot;&quot;</code>来使用原声字符串，有点类似Python的<code>&#39;&#39;&#39;&#39;&#39;&#39;</code>，即内部不进行转义操作。  </li><li>字符串模板：kotlin可在字符串中使用<code>模板表达式</code>，即可以在””的字符串中通过<code>$变量名</code>或者<code>${表达式}</code>的方式插入值在字符串中，比Java省略了通过 %s %d等格式符再format的操作。有点类似shell </li></ul><h5 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h5><ul><li>嵌套类：<ul><li>kotlin的嵌套类跟Java一样用class声明即可，但是！默认是静态内部类。。需要声明为内部类的话则需要在声明处加inner 即 <code>inner class SubClass</code>，当初没注意踩了内部类和静态内部类的坑。</li></ul></li><li><p>对象表达式和对象声明：</p><ul><li>对象表达式为实现匿名内部类，因为kotlin没有new关键字可以直接创建接口或者抽象类对象，<br>此时可以通过对象表达式创建，方式为:<pre><code class="java">button.setOnClickListener(object :View.OnClickListener{  override fun onClick(v: View?) {      TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.  }})</code></pre></li><li>对象声明：在类中通过onject声明.官方文档的解释代码如下：<pre><code class="java">  object DataProviderManager {  fun registerDataProvider(provider: DataProvider) {   // ……  }   val allDataProviders: Collection&lt;DataProvider&gt;  get() = // ……}</code></pre>即声明在类中后，类即有了一个DataProviderManager的静态类，并且会自动为其创建一个对象，实现原理如Java单例模式的静态内部类。</li><li><p>伴生对象：跟对象声明一样，不过不是 <code>object DataProviderManager</code>而是<code>companion object</code>作用为定义类的静态成员，弥补kotlin中没有static关键字，因此定义在此的成员可以通过<code>类名.</code> 限定符调用</p><blockquote><p>请注意， 即使伴⽣对象的成员看起来像其他语⾔的静态成员， 在运⾏时他们 仍然是真实对象的实例成员， ⽽且， 例如还可以实现接⼝：  </p></blockquote><p>  这句话有点看不懂，，，求解释</p></li></ul></li><li><p>类委托：委托模式的支持实现，恶补了下委托模式，原来代理模式又名委托模式。。。</p><ul><li>使用方式：<blockquote></blockquote><pre><code class="java">interface Base {  fun print()} class BaseImpl(val x: Int) : Base {  override fun print() { print(x) }} /*** by关键字即是类委托的实现。 * 用法理解为Derived类实现Base接口，* 此时Derived类有了print方法* 通过by接口表示将b对象的方法委托给Derived对象* 从而当调用Derived对象的print方法时，* 实际调用的是构造方法里面b对象的方法* 因此Derived(b).print() 和 Derived(b).b.print()是一样的*/class Derived(val b: Base) : Base by bfun main(args: Array&lt;String&gt;) {  val b = BaseImpl(10)  Derived(b).print() // 输出 10}</code></pre></li><li>注：暂时没发现什么地方可以用到。。。代理模式还没用过</li></ul></li><li>属性委托：同委托模式的应用，作用如下。。<ul><li>延迟属性 （lazy properties） : 其值只在⾸次访问时计算，</li><li>可观察属性 （observable properties） : 监听器会收到有关此属性变更的通知，</li><li>把多个属性储存在⼀个映射 （map） 中， ⽽不是每个存在单独的字段中。</li></ul></li></ul><p><a id="1" href="http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/index.html" target="_blank" rel="noopener">Java中的自动装箱与拆箱</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2017/04/21/git/"/>
      <url>/2017/04/21/git/</url>
      
        <content type="html"><![CDATA[<ul><li><p>设置代理<br><code>`</code>bash</p><pre><code>  git config --global https.proxy http://127.0.0.1:1080  git config --global https.proxy https://127.0.0.1:1080</code></pre></li></ul><pre><code>- 取消代理    ```bash        git config --global --unset http.proxy        git config --global --unset https.proxy</code></pre><ul><li>强行拉取远程仓库覆盖本地仓库<pre><code class="bash">  git reset --hard  git pull</code></pre></li><li>本地分支强行覆盖远程分支<pre><code class="bash">  git push --force [远程名] [本地分支名]:[远程分支名]</code></pre></li><li>储藏文件改变<pre><code class="bash">  git stash #储藏当前改变的文件到工作空间，方便不提交的情况下拉取远程代码等，可以避免无用的commit  git stash list #显示当前的储藏，并提供编号  git stash apply 编号 #将工作空间中储藏区的改变重新拉回文件夹中，拉取后不删除储藏  git stash pop 编号 #同apply，拉取后删除</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dagger2_note</title>
      <link href="/2017/04/18/dagger2-note/"/>
      <url>/2017/04/18/dagger2-note/</url>
      
        <content type="html"><![CDATA[<h2 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h2><blockquote><p>提供创建类实例<br>使用Module来提供实例而不是直接用@Inject注解依赖类构造方法的好处是，<br>对于一些第三方类，不需要直接改动第三方类的代码添加@Inject<br><code>`</code>java<br>@Module //@Provide标注的方法必须在@Module里面<br>public class AModule{<br>  @Provide //表示提供某某实例<br>  A provideA(){return new A();}<br>}</p></blockquote><pre><code>---## @Inject&gt;标注目标类中所依赖的其他类，同样用注解来标注所依赖的其他类的构造函数```javapublic class A{        @Inject        B b;   }   class B{       @Inject       B(){       }   }</code></pre><hr><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><blockquote><p>在目标类中所依赖的其他类与其他类的构造函数之间可以起到一个桥梁的作用。<br>当一个类被@Component注解时，<code>make project</code>后将会生成对应的Dagger<strong><em>(这里的</em></strong>为该接口名)<br>当Compoent桥梁提供注入时，查找顺序首先为Module类里面提供的实例，如若找不到了再到依赖对象内去寻找@Inject注入构造器<br><code>`</code>java<br>/* Module 参数 表明到时候注入时去寻找的提供实例的类模板，加大括号可以添加多个类模板 </p><ul><li>dependencies 参数 表明添加另一个Component作为当前Component的依赖，则当前类自动拥有依赖项的Module提供的实例<br>*/<br>@Component(Module = {AModule.class})<br>public interface AComponent(){</li></ul></blockquote><p>}</p><pre><code>---## @Singleton&gt;单例注解，让依赖变为单例模式- @Inject注入下的使用    ```java     @Singleton     public class A{             @Inject             public A(){             }     }</code></pre><ul><li>@Module注入下的使用<pre><code class="java">   @Module    public class AModule{     @Singleton     @Provide      A provideA(){return new A();}   }</code></pre></li><li>以上两种对应的Component类都需要加上@Singleton<br><code>`</code>java<br>@Singleton<br>@Component(Module = {AModule.class})<br>public interface AComponent(){</li></ul><p>}</p><pre><code>---## @Scope&gt;自定义注解来制定注入对象的作用域，从而产生局部单例的效果(例如在MainActivity单例，在LoginActivity不是),对应每个Component一个实例  &gt; - [以下总结来自文章 【 Dagger2 Scope 注解能保证依赖在 component 生命周期内的单例性吗？】](https://blog.piasy.com/2016/04/11/Dagger2-Scope-Instance)&gt; - component 的 inject 函数不要声明基类参数  &gt;  - Scope 注解必须用在 module 的 provide 方法上，否则并不能达到局部单例的效果&gt; - 如果 module 的 provide 方法使用了 scope 注解，那么 component 就必须使用同一个注解，否则编译会失败&gt; - 如果 module 的 provide 方法没有使用 scope 注解，那么 component 和 module 是否加注解都无关紧要，可以通过编译，但是没有局部单例效果&gt; - 对于直接使用 @Inject 构造函数的依赖，如果把 scope 注解放到它的类上，而不是构造函数上，就能达到局部单例的效果了---## @Qualifier&gt;限定符，当一个Module中提供了同一个类的多个实例时，可以通过限定符选择相应的实例，`@Named`是Dagger2对于`@Qualifier`一个默认实现，用法如下：```java@Module public class AModule{        @Named(&quot;default&quot;)        @Provide         A provideA(){return new A();}        @Named(&quot;something&quot;)        @Provide         A provideA2(){return new A(&quot;something&quot;);}}public class Main(){  @Inject  @Named(&quot;something&quot;)  A somethingA;}</code></pre><p>也可以自定义限定符的实现</p><pre><code class="java">@Qualifier@Documented@Retention(RUNTIME)public @interface CustonQualiftier{        String value() default &quot;&quot;;//如若不打算传参，不加这个参数也可以}</code></pre><p>而后用法同<code>@Named</code>相似</p><hr><h3 id="依赖倒置原则："><a href="#依赖倒置原则：" class="headerlink" title="依赖倒置原则："></a><strong><code>依赖倒置原则</code></strong>：</h3><h5 id="抽象不应该依赖于具体，具体应该依赖于抽象"><a href="#抽象不应该依赖于具体，具体应该依赖于抽象" class="headerlink" title="抽象不应该依赖于具体，具体应该依赖于抽象"></a><em>抽象不应该依赖于具体，具体应该依赖于抽象</em></h5><p>解释如下，</p><ul><li>当抽象依赖于具体时，抽象类基本很少改动(里式替换原则)，当具体类A换了另一个具体类时B，便需要到抽象类修改依赖A为B</li><li>当具体依赖于抽象时，由于里式替换原则，当抽象类A的实现类B替换为抽象类B时，只需要通过注入的方式修改抽象类的实现类即可，最简单的注入如 setXX() 或者 构造方法注入  </li></ul><hr><p> <em>MVP 模式下的依赖倒置应用：</em></p><ul><li>Model 底层操作类，如数据库，网络请求</li><li>View 视图层 数据的展示,如刷新按钮，图片加载</li><li>Presenter 业务逻辑层, 链接V层和M层，因此持有M和V层的引用，将M层数据加以业务逻辑判断后传输给V层,</li></ul><p>根据软件设计原则，Presenter是属于高层次模块，View是低层次模块，因此View层需要实现接口，而Presenter不需要(关于Presenter要不要实现接口是一个受争议的话题，略),View层实现IView(基类)接口后，基于里式替换原则，一个Presenter在某种情况下可以在多个View中复用。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LAMP折腾记录</title>
      <link href="/2017/04/06/LAMP%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/04/06/LAMP%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><blockquote><p>Linux Ubuntu 16.04.1<br>Linux下CentOS和Ubuntu的配置文件略有不同<br>CentOS的配置文件为httpd.conf<br>Ubuntu为apache2.conf</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code class="shell">sudo apt install mysql-server apache2 php</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><p>配置虚拟主机<br>在/etc/apache2/sites-enabled/000-default.conf添加如下配置：</p><pre><code class="bash">      &lt;VirtualHost *:8080&gt; #监听的端口号        ServerAdmin webmaster@localhost #服务器返回给客户端的错误信息中包含的管理员邮件地址 可忽略        DocumentRoot /home/feng/workspace/php/MsgBoard# 网站的根目录文件夹，注意这个文件夹的权限必须是755，并且这个文件夹的上层文件夹的权限也是755,不然会出现403错误。        ErrorLog ${APACHE_LOG_DIR}/error_8080.log # 错误日志位置        CustomLog ${APACHE_LOG_DIR}/access_8080.log combined #记录着访问日志      &lt;/VirtualHost&gt;</code></pre></li><li>目录树及文件说明<ul><li>apache2.conf      <strong>apache配置文件</strong></li><li>envvars <strong>apache环境变量配置文件</strong></li><li>ports.conf <strong>监听端口配置文件</strong></li><li>magic <strong>可以设置不同MIME类型文件的一些特殊标识</strong></li><li>mods-enabled <strong>已经启用的模块</strong></li><li>mods-available <strong>已经安装的模块</strong></li><li>sites-enabled <strong>已启用站点配置</strong></li><li>sites-available <strong>可用站点配置</strong></li><li>conf-enabled <strong>已启用的Apache配置</strong></li><li>conf-available <strong>所有Apache配置</strong></li></ul></li><li>相关命令<ul><li>a2disconf a2enconf <strong>禁止/启用相关配置文件</strong></li><li>a2dismod a2enmod <strong>禁止/启用相关模块</strong></li><li>a2dissite a2ensite <strong>禁止/启用相关虚拟主机</strong></li><li>apache2ctl <strong>apache http 服务控制接口</strong></li></ul></li><li>相关知识<ul><li><directory "路径"></directory>标签定义了用户访问控制，后面的路径指定要控制的目标路径</li><li>Options 选项<ul><li>Indexes: 是否允许索引页面文件（不安全，建议关闭）；</li><li>FollowSynLinks: 是否跟随软链接文件（不安全，建议关闭）；</li><li>SymLinksifOwnerMatch:相对安全的跟随软链接指令（如果软链接文件的属主与网页访问用户匹配则允许）</li><li>ExecCGI：是否允许执行CGI脚本;</li><li>All</li><li>None</li></ul></li><li>AllowOverride 指允许使用与认证授权相关的指令</li><li>directive-type可以是下列各组指令之一：</li><li>AuthConfig：允许使用与认证授权相关的指令(AuthDBMGroupFile, AuthDBMUserFile, AuthGroupFile, AuthName, AuthType, AuthUserFile, Require, 等)。</li><li>AuthName “Realm”：认证名称是什么，描述信息，可以任意给，告诉客户端这里为什么要认证</li><li>AuthType：认证类型，一般有两种：Basic：基本认证；digest：摘要认证（不是所有浏览器都支持）；通常都是基本认证；</li><li>AuthUserFile：用户认证文件所存放的位置（可以是文本文件、数据库、ldap等，通过动态加载相应的模块实现，默认是保存在文本文件中） </li><li>AuthGroupFile：组文件所存放的位置（基于组用户的认证与用户类似）</li><li>Require：指明认证的用户是哪些，可以是多个用户，用户名之间用空格隔开；如果是所有合法用户，则为“valid-user”；</li></ul></li><li>访问控制：<ul><li>在Apache2.4以前版本,通过以下命令控制：<pre><code class="bash">   Order：定义allow和deny哪个为默认法则；写在后面的为默认法则：写在前面的指令没有显式定义的即受后面的指令控制；   Order allow,deny   Deny from 192.168.1.2       #拒绝所有的iP访问   allow from 192.168.1.0/24   #仅允许192.168.1.0网段的IP访问（但拒绝192.168.1.2：最小范围优先匹配原则）</code></pre></li><li>在Apache2.4及以后版本，通过Require控制：<pre><code class="bash">   Require all granted # 允许所有请求   Require all denied  # 允许所有请求   Require ip 127.0.0.1 # 允许ip127.0.0.1的请求   Require host localhost # 允许主机名localhost的请求</code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4></li></ul></li><li>目前水平那是不可能的╮(╯▽╰)╭ <h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4></li><li><a href="http://kimi.it/281.html" target="_blank" rel="noopener">AuthConfig</a><blockquote><p>AuthConfig 允许使用与认证授权相关的指令(AuthDBMGroupFile, AuthDBMUserFile, AuthGroupFile, AuthName, AuthType, AuthUserFile, Require, 等)。FileInfo 允许使用控制文档类型的指令(DefaultType, ErrorDocument, ForceType, LanguagePriority, SetHandler, SetInputFilter, SetOutputFilter, mod_mime中的 Add<em> 和 Remove</em> 指令等等)、控制文档元数据的指令(Header, RequestHeader, SetEnvIf, SetEnvIfNoCase, BrowserMatch, CookieExpires, CookieDomain, CookieStyle, CookieTracking, CookieName)、mod_rewrite中的指令(RewriteEngine, RewriteOptions, RewriteBase, RewriteCond, RewriteRule)和mod_actions中的Action指令。Indexes 允许使用控制目录索引的指令(AddDescription, AddIcon, AddIconByEncoding, AddIconByType, DefaultIcon, DirectoryIndex, FancyIndexing, HeaderName, IndexIgnore, IndexOptions, ReadmeName, 等)。Limit 允许使用控制主机访问的指令(Allow, Deny, Order)。Options[=Option,…] 允许使用控制指定目录功能的指令(Options和XBitHack)。可以在等号后面附加一个逗号分隔的(无空格的)Options选项列表，用来控制允许Options指令使用哪些选项。</p></blockquote></li><li><a href="http://baike.baidu.com/item/htaccess?fr=aladdin" target="_blank" rel="noopener">htaccess</a><blockquote><p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p></blockquote></li><li>参考文章<ul><li><a href="http://sweetpotato.blog.51cto.com/533893/1657668" target="_blank" rel="noopener">Linux运维实战之Apache的基本配置（全局配置、主服务器配置</a></li><li><a href="http://www.cnblogs.com/top5/archive/2009/09/22/1571709.html" target="_blank" rel="noopener">Apache的Order Allow,Deny 详解</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql日常笔记</title>
      <link href="/2017/04/04/mysql%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/04/04/mysql%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>创建数据库并指明utf8编码(否则中文乱码)<pre><code class="mysql">  CREATE DATABASE 数据库名 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</code></pre></li><li>删除数据库<pre><code class="mysql">  DROP DATABASE 数据库名;</code></pre></li><li>创建用户<pre><code class="mysql">  CREATE &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;  -- 主机名是用 % 表示通配符允许所有主机 localhost 表示本地主机</code></pre></li><li>用户授权<pre><code class="mysql">  GRANT PRIVILEGES ON 数据库名.数据库表 TO &#39;用户名&#39;@&#39;主机名&#39;  -- 这里的PRIVILEGES 指insert delete等权限，下附权限表 ALL PRIVILEGES表示所有权限  -- eg:  GRANT INSERT DELETE ON 数据库名.数据库表 TO &#39;用户名&#39;@&#39;主机名&#39;  GRANT ALL PRIVILEGES ON 数据库名.数据库表 TO &#39;用户名&#39;@&#39;主机名&#39;</code></pre>|           权限              |        权限级别            |                                                        权限说明                                                           |<br>|:———————–:    |:———————-:    |:———————————————————————————————————————:    |<br>| CREATE                      | 数据库、表或索引           | 创建数据库、表或索引权限                                                                                                  |<br>| DROP                        | 数据库或表                 | 删除数据库或表权限                                                                                                        |<br>| GRANT OPTION                | 数据库、表或保存的程序     | 赋予权限选项                                                                                                              |<br>| REFERENCES                  | 数据库或表                 |                                                                                                                           |<br>| ALTER                       | 表                         | 更改表，比如添加字段、索引等                                                                                              |<br>| DELETE                      | 表                         | 删除数据权限                                                                                                              |<br>| INDEX                       | 表                         | 索引权限                                                                                                                  |<br>| INSERT                      | 表                         | 插入权限                                                                                                                  |<br>| SELECT                      | 表                         | 查询权限                                                                                                                  |<br>| UPDATE                      | 存储过程                   | 更新权限                                                                                                                  |<br>| CREATE VIEW                 | 视图                       | 创建视图权限                                                                                                              |<br>| SHOW VIEW                   | 视图                       | 查看视图权限                                                                                                              |<br>| ALTER ROUTINE               | 存储过程                   | 更改存储过程权限                                                                                                          |<br>| CREATE ROUTINE              | 存储过程                   | 创建存储过程权限                                                                                                          |<br>| EXECUTE                     | 存储过程                   | 执行存储过程权限                                                                                                          |<br>| FILE                        | 服务器主机上的文件访问     | 文件访问权限                                                                                                              |<br>| CREATE TEMPORARY TABLES     | 服务器管理                 | 创建临时表权限                                                                                                            |<br>| LOCK TABLES                 | 服务器管理                 | 锁表权限                                                                                                                  |<br>| CREATE USER                 | 服务器管理                 | 创建用户权限                                                                                                              |<br>| PROCESS                     | 服务器管理                 | 查看进程权限                                                                                                              |<br>| RELOAD                      | 服务器管理                 | 执行flush-hosts, flush-logs, flush-privileges, flush-status, flush-tables, flush-threads, refresh, reload等命令的权限     |<br>| REPLICATION CLIENT          | 服务器管理                 | 复制权限                                                                                                                  |<br>| REPLICATION SLAVE           | 服务器管理                 | 复制权限                                                                                                                  |<br>| SHOW DATABASES              | 服务器管理                 | 查看数据库权限                                                                                                            |<br>| SHUTDOWN                    | 服务器管理                 | 关闭数据库权限                                                                                                            |<br>| SUPER                       | 服务器管理                 | 执行kill线程权限                                                                                                          |<br>| USAGE                     | 服务器管理              | 没有权限<pre><code>                                              |</code></pre></li></ul><hr><table><thead><tr><th style="text-align:center">权限分布</th><th style="text-align:center">可能的设置的权限</th></tr></thead><tbody><tr><td style="text-align:center">表权限</td><td style="text-align:center">‘Select’, ‘Insert’, ‘Update’, ‘Delete’, ‘Create’, ‘Drop’, ‘Grant’, ‘References’, ‘Index’, ‘Alter’</td></tr><tr><td style="text-align:center">列权限</td><td style="text-align:center">‘Select’, ‘Insert’, ‘Update’, ‘References’</td></tr><tr><td style="text-align:center">过程权限</td><td style="text-align:center">‘Execute’, ‘Alter Routine’, ‘Grant’</td></tr></tbody></table><hr><ul><li>权限相关<pre><code class="mysql">  -- 刷新权限  flush privileges;  -- 查看权限  show grants;  -- 查看某个用户权限  show grants for &#39;用户名&#39;@&#39;主机名&#39;;  -- 回收权限  REVOKE DELETE ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;  -- 删除用户  DROP USER &#39;用户名&#39;@&#39;主机名&#39;  -- 账户重命名  RENAME USER &#39;用户名&#39;@&#39;主机名&#39; TO &#39;新用户名&#39;@&#39;新主机名&#39;;  -- 修改密码  SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = &#39;新密码&#39;:  -- 查看所有用户  SELECT User FROM mysql.user;  -- 查看所有数据库  SHOW DATABASES;  -- 查看所有表名  SHOW TABLES;</code></pre></li><li>查看数据库或表创建语句<pre><code class="mysql"> SHOW CREATE DATABASE 数据库名; SHOW CREATE TABLE 数据表名;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记糗百的一次爬虫经历</title>
      <link href="/2017/03/30/%E8%AE%B0%E7%B3%97%E7%99%BE%E7%9A%84%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%8F%E5%8E%86/"/>
      <url>/2017/03/30/%E8%AE%B0%E7%B3%97%E7%99%BE%E7%9A%84%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h5 id="事情起源："><a href="#事情起源：" class="headerlink" title="事情起源："></a>事情起源：</h5><pre><code>  一次无聊的想要做点东西，发现数据库没点东西，然后就想到去糗百爬点东西，然后就开始了入坑。。。</code></pre><h5 id="工具：Python3-scrapy框架"><a href="#工具：Python3-scrapy框架" class="headerlink" title="工具：Python3 scrapy框架"></a>工具：Python3 scrapy框架</h5><p>想起以前的爬虫经历，几乎没遇到过什么防爬虫措施，于是就直接开始了调试准备get√xpath表达式的时候，有了第一个坑，</p><pre><code class="shell">scrapy shell http://www.qiushibaike.com/text/</code></pre><p>然后！果断报错了，<img src="/2017/03/30/记糗百的一次爬虫经历/糗百_1.png" alt></p><h4 id="然而我竟然就去谷歌-twisted-框架的这个错误，结果可想而知没有答案，最后突然想到一点，好像。。。糗百一直被作为爬虫入门博客的例子。。。估计是被爬怕了，加了-反爬虫机制，，，"><a href="#然而我竟然就去谷歌-twisted-框架的这个错误，结果可想而知没有答案，最后突然想到一点，好像。。。糗百一直被作为爬虫入门博客的例子。。。估计是被爬怕了，加了-反爬虫机制，，，" class="headerlink" title="然而我竟然就去谷歌 twisted 框架的这个错误，结果可想而知没有答案，最后突然想到一点，好像。。。糗百一直被作为爬虫入门博客的例子。。。估计是被爬怕了，加了 反爬虫机制，，，"></a>然而我竟然就去谷歌 <code>twisted</code> 框架的这个错误，结果可想而知没有答案，最后突然想到一点，好像。。。糗百一直被作为爬虫入门博客的例子。。。估计是被爬怕了，加了 <code>反爬虫机制</code>，，，</h4><ul><li>于是开始谷歌scrapy伪装浏览器怎么写，最后在项目配置文件setting.py中的<code>DEFAULT_REQUEST_HEADERS</code>加入以下伪装：  <pre><code class="scrapy">&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0&#39;,&#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,&#39;Accept-Language&#39;: &#39;en-US,en;q=0.5&#39;,&#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,&#39;Cookie&#39;:&#39;&#39;&#39;_xsrf=2|da663c38|074b39a46ce47715d5a3376af4b154b7|1490869563; _qqq_uuid_=&quot;2|1:0|10:1490869563|10:_qqq_uuid_|56:ZGY2MzY5ZmI1MTJkNmIzZjQ1ODM1YTVlYTE4NjQ0ZjBhOWEzMmViNg==|cc49d57f4513ac2d3d35b453fe41b11c35c66ac1eb6f214ad7f81f013e3789ba&quot;; Hm_lvt_2670efbdd59c7e3ed3749b458cafaa37=1490869564; Hm_lpvt_2670efbdd59c7e3ed3749b458cafaa37=1490869564; _ga=GA1.2.136222138.1490869564; _gat=1&#39;&#39;&#39;,&#39;Connection&#39;: &#39;keep-alive&#39;,&#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,&#39;If-None-Match&#39;: &quot;9de88e87dd2d3140edc8af02a7bc9516598bc9fc&quot;}</code></pre>好了，<pre><code class="shell">scrapy shell http://www.qiushibaike.com/text/</code></pre>爬虫调试没问题了，next，<br>写好了一切逻辑后，代码如下：<br><code>`</code>python<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1>import scrapy<br>from qiushibaike.items import TextItem</li></ul><p>class TextSpider(scrapy.Spider):<br>    name = “text”<br>    allowed_domains = [“qiushibaike.com”]<br>    start_urls = [‘<a href="http://qiushibaike.com/text/page/1&#39;]" target="_blank" rel="noopener">http://qiushibaike.com/text/page/1&#39;]</a></p><pre><code>def parse(self, response):    item = TextItem()    li = response.xpath(&#39;&#39;&#39;//*[@class=&#39;content&#39;]/span&#39;&#39;&#39;)    liContent = list()    for i in li:        liContent.append(&#39;&#39;.join(i.xpath(&#39;text()&#39;).extract()))    item[&#39;content&#39;] = liContent    yield item    #提取出下一页链接    nextPage = response.xpath(&quot;//*[@class=&#39;next&#39;]/parent::a/@href&quot;).extract()    if len(nextPage) &gt; 0:        nextPage = &#39;http://www.qiushibaike.com&#39; + nextPage[0]        yield scrapy.Request(nextPage, callback=self.parse)</code></pre><pre><code>* 然后,  ```shellscrapy crawl text  </code></pre><p>这里去糗百网站看了，text这个栏目是有35页的，但我爬到第12页就报错了，<br><img src="/2017/03/30/记糗百的一次爬虫经历/糗百_2.png" alt>,</p><ul><li>好吧，503错误，Web 服务器目前无法处理HTTP 请求,具体自行维基百度，这个错误对于爬虫来说，还是很容易看出来是哪出问题的：爬虫速度太快，服务器承载不了报错。既然太快，那就需要限制爬虫，好在作为一个强大的爬虫框架，scrapy也有想到了这一点，也有相应的限制措施，以下是在setting.py文件下增加如下配置即可，<pre><code>AUTOTHROTTLE_ENABLED = True #开启scrapy的自动限速扩展 注：默认不开启，False# The initial download delayAUTOTHROTTLE_START_DELAY = 5 #爬虫启动等待时间，单位秒# The maximum download delay to be set in case of high latenciesAUTOTHROTTLE_MAX_DELAY = 60 # 爬虫最大等待时间，这里是照搬官网，用不到这个设置DOANLOAD_DELAY = 5 # 爬虫中间下载件每次下载的间隔时间CONCURRENT_REQUESTS_PER_DOMAIN = 1 # 爬虫的对单个IP进行并发请求的最大值</code></pre>如此，爬虫便可以爬完35页了，<br>缺点：速度贼慢！</li></ul><p>总结：以前爬一些小网站没有这些对应的反爬虫措施，倒是大意了，作为一只爬虫，最基本的怎能不伪装成浏览器呢。。。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一天</title>
      <link href="/2017/03/30/%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2017/03/30/%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="第一天搭建好的博客，用作随笔无聊更新写点东西吧。嗯，就这样吧"><a href="#第一天搭建好的博客，用作随笔无聊更新写点东西吧。嗯，就这样吧" class="headerlink" title="第一天搭建好的博客，用作随笔无聊更新写点东西吧。嗯，就这样吧"></a>第一天搭建好的博客，用作随笔无聊更新写点东西吧。嗯，就这样吧</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 闲扯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&amp;id=429849712&amp;auto=1&amp;height=430" style="width: 100%; height: 100%; position: absolute; top: 0px; left: 0px;"></iframe>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
